<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>57之塔</title>
  
  
  <link href="http://azkoree.github.io/atom.xml" rel="self"/>
  
  <link href="http://azkoree.github.io/"/>
  <updated>2025-12-29T05:17:14.562Z</updated>
  <id>http://azkoree.github.io/</id>
  
  <author>
    <name>五十七</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自用的csp笔刷</title>
    <link href="http://azkoree.github.io/posts/52686/"/>
    <id>http://azkoree.github.io/posts/52686/</id>
    <published>2025-12-29T05:11:03.000Z</published>
    <updated>2025-12-29T05:17:14.562Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>先前在xhs发的csp笔刷分享，在这也放一下。</p><p><img src="https://img.57hmpg.top/file/1766985414031_%E6%8F%92%E7%94%BB5.png" alt="插画5.png"></p><p><img src="https://img.57hmpg.top/file/1766985412135_%E6%8F%92%E7%94%BB4.png" alt="插画4.png"></p><p>没了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;先前在xhs发的cs</summary>
      
    
    
    
    <category term="绘画相关" scheme="http://azkoree.github.io/categories/%E7%BB%98%E7%94%BB%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="绘画" scheme="http://azkoree.github.io/tags/%E7%BB%98%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>vitepress搭建的oc站已上线！</title>
    <link href="http://azkoree.github.io/posts/13716/"/>
    <id>http://azkoree.github.io/posts/13716/</id>
    <published>2025-12-27T09:52:51.000Z</published>
    <updated>2025-12-27T15:05:47.247Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>眼尖的友友们可能已经发现，导航栏多出了一个新栏目。</p><p><img src="https://img.heliar.top/file/1766829238451_image.png" alt="image.png"></p><p>至于里面长什么样，就不截给大家看了，因为目前还是真的毛坯房，完全是默认模板。不过点进去还是大概能知道是个什么框架。<br>虽然我说我是真的不会计算机，但是在目前的大形势下，还是需要给各位苦于向他人分享oc的oc人们，提供一个参考。</p><div class="note warning flat"><p><strong>观前一盾</strong><br>然而我还是不懂这方面的知识，令人感叹<br>所以还是解答不了太多问题，大多也都是抄别人的，也希望大佬们不要见怪。</p></div><h1 id="适用人群"><a href="#适用人群" class="headerlink" title="适用人群"></a>适用人群</h1><ul><li>对计算机基础的要求不高</li><li>但如果是像我这样的零基础，还是需要琢磨上一段时间，所以不能太怕麻烦</li><li>对于网站的美观度没有太多要求，甚至在线文档足矣</li><li>重设定，追求oc及其世界观的设定的完善性，需要一个用于整理的平台，文字 &gt; 图片</li><li>虽然最后搭建的网站不一定需要，但搭建的过程中要用到github和vercel，访问可能不稳定，所以自己最好有科学上网的能力</li><li>申请域名可选，但个人还是建议最好绑一个</li></ul><h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>我是在vercel上部署的。我自己不会讲，这里直接就给大家推荐一些文字和视频教程，具体的环境搭建和操作步骤请参考下面教程一步步来。</p><p><a href="https://vitepress.dev/zh/guide/what-is-vitepress">vitepress官方文档</a><br>这是vitepress的官方文档，有中文。不过这个文档比较跳跃，尤其是部署部分，零基础可能看不太懂。</p><p><a href="https://zhuanlan.zhihu.com/p/719897686">VitePress+Vercel+GitHub+NameSilo自定义域名 搭建个人博客网站 搭建项目文档网站</a><br>来自知乎，讲得比较详细，个人推荐看这个</p><p><a href="https://www.bilibili.com/video/BV1ajBbYuEB1/?spm_id_from=333.337.search-card.all.click&vd_source=b5a85a2c6b245b754aac0f5ec954488d">【建站教程】小白也可以轻松拥有自己的文档网站，手把手教你搭建VitePress，由Vite和Vue驱动的静态网站生成器</a><br>视频教程+1，不过他用的是自己的服务器，从第六部分网站上线开始就可以不用看了。</p><p>要注意的一点是，<strong>在初始化vitepress项目的时候一定要设定好路径！具体见第二条链接，否则都是404</strong></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>前面所推荐的一些教程中也有涉及到部署，但是都比较跳跃，对于从来没用过github的友友们来说可能太过超前了。（我也不会）<br>步骤进行到我们已经用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vitepress build</span><br></pre></td></tr></table></figure><p>来生成网站的静态文件，此时就差将它部署到vercel上了。但身为零基础的你会发现在进行deploy的时候经常报错，那是因为你的静态文件压根就没有上传到git上，这当然是没法成功<br>所以在vercel新建工程之前，我们要把本地的库先同步到github上<br><a href="https://www.cnblogs.com/ljbguanli/p/19356742">【超详细】从0到1教你将本地方案上传到GitHub及常见问题应对</a><br>照着这个教程来就好了。<br>以后要更新网站，也是要将本地仓库push到github上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1. 添加修改的文件到暂存区</span><br><span class="line">git add .</span><br><span class="line"># 2. 提交修改（说明本次更新内容）</span><br><span class="line">git commit -m &quot;修复xxx问题/新增xxx功能&quot;</span><br><span class="line"># 3. 推送到远程仓库</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>（这里要一行一行来，应该不会有人真的全复制粘贴上去吧）</p><p>看一眼仓库确定已经成功同步，再在vercel进行部署。</p><h1 id="（可选）绑定域名"><a href="#（可选）绑定域名" class="headerlink" title="（可选）绑定域名"></a>（可选）绑定域名</h1><p>你可以选择绑一个自己申请的域名，也可以不绑，vercel部署最好的地方就是可以白嫖vercel的免费域名（不是）<br>但是vercel的域名在大陆访问并不稳定，而且太长，有点丑。所以建议还是自己申请一个域名。只申请域名不用在国内服务器<em>应该</em>是不用备案的。<br>在Vercel绑定域名的方法可以自己去搜（因为我自己写不下去了），不过绑了自己的域名可能还是访问不稳定，这里可以使用<br><a href="https://github.com/xingpingcn/enhanced-FaaS-in-China">提升部署在cloudflare、vercel或netlify的网页在中国的访问速度和稳定性</a><br>参考readme文件来进行设置，本站和oc站都使用了这个。用完记得给大佬一个star。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>只要搭建部署能弄好，剩下的主题配置和写作就没有那么难，这里不再赘述。<br>说实话，我感觉要长期搞个人网站的话，最好还是搞个备案……<br>但是长期坚持维护和写作下去才是最重要滴！<br>这里也只是给各位一个新的方向，网上资料很多，希望大家可以自己多多钻研。（因为我自己都是三脚猫水平）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;眼尖的友友们可能已经</summary>
      
    
    
    
    <category term="经验分享" scheme="http://azkoree.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="学习" scheme="http://azkoree.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="oc相关" scheme="http://azkoree.github.io/tags/oc%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>2025的画手年度总结</title>
    <link href="http://azkoree.github.io/posts/df5867ea/"/>
    <id>http://azkoree.github.io/posts/df5867ea/</id>
    <published>2025-12-19T15:13:07.000Z</published>
    <updated>2025-12-25T08:02:45.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>又到了做年度总结的时候，我发现我现在已经到了怎么都凑不出每月一张图的阶段（不论是我的眼界还是精力上），不幸的。<br>不过该做的还是得做。在这里放一些今年画的算是用了心的画。按设备分类，尽可能按时间排序。为了节省上传时间，图全部都压过，想看原图自己去蓝p或者黑x或者lof看。<br>看了眼好像基本都是同人，从一拳到逸剑到远征，也是一跳跳三个，无敌了（</p><h1 id="ipad端"><a href="#ipad端" class="headerlink" title="ipad端"></a>ipad端</h1><p>今年不是很喜欢用ipad了，比较喜欢数位板绘画那种（故作）松散的感觉。</p><p><img src="/posts/df5867ea/ipad1.jpg" alt="蹭了一波当时黑x的一拳圈的重绘单行本封面的活动，其实我都没打tag，但还是给翻出来了，两百多赞，还涨了点粉。然后我就淡坑了（"><br><img src="/posts/df5867ea/ipad2.jpg" alt="投了缩时摄影过程，不过我也隐藏了。"><br><img src="/posts/df5867ea/ipad3.jpg" alt="我还是比较喜欢我画的倒影，但是这斗笠的透视是人能画出来的？（当然现在也画不好）"><br><img src="/posts/df5867ea/ipad4.jpg"><br><img src="/posts/df5867ea/ipad5.jpg"><br><img src="/posts/df5867ea/ipad6.jpg" alt="在贴吧看到有人发这张图，倒不是说不接受无端转载，只是感觉挺微妙的（"></p><p>好的ipad组就这样结束了（</p><h1 id="pc端"><a href="#pc端" class="headerlink" title="pc端"></a>pc端</h1><p>这里想贴一下逸剑草稿流小短漫，因为个人真的是比较用心的在想剧情，虽然我自己现在瞅着还是尬。得到的评论也比较多（<br>指路蓝p：131344477的第64p开始，或者直接拉到附录看。</p><p><img src="/posts/df5867ea/0509-3.jpg"><br><img src="/posts/df5867ea/0510-1.jpg"><br><img src="/posts/df5867ea/0515_1.jpg"><br><img src="/posts/df5867ea/0626-1.jpg"><br><img src="/posts/df5867ea/0712-1.jpg"><br><img src="/posts/df5867ea/0723-2.jpg"><br><img src="/posts/df5867ea/0803-1.jpg"><br><img src="/posts/df5867ea/0814-1.jpg"><br><img src="/posts/df5867ea/0915-1.jpg"><br><img src="/posts/df5867ea/1125-01.jpg"><br><img src="/posts/df5867ea/1213-1.jpg"><br><img src="/posts/df5867ea/1216-1.jpg"><br><img src="/posts/df5867ea/1216-2.jpg"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我没什么可说的，也没有确切的消息藏在这个文章。<br>好吧确实没什么可总结的，现在没什么时间钻研基础，只能找些歪门邪道，希望2026年能稍微上进一点吧Orz</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>前面所说的逸剑莫名小短漫有点太长太占篇幅，所以放在这里。</p><p><img src="/posts/df5867ea/0410-1.jpg"></p><p><img src="/posts/df5867ea/0410-2.jpg"></p><p><img src="/posts/df5867ea/0410-3.jpg"></p><p><img src="/posts/df5867ea/0410-4.jpg"></p><p><img src="/posts/df5867ea/0410-5.jpg"></p><p><img src="/posts/df5867ea/0410-6.jpg"></p><p><img src="/posts/df5867ea/0410-7.jpg"></p><p><img src="/posts/df5867ea/0410-8.jpg"></p><p><img src="/posts/df5867ea/0410-9.jpg"></p><p><img src="/posts/df5867ea/0410-10.jpg"></p><p><img src="/posts/df5867ea/0410-11.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="绘画相关" scheme="http://azkoree.github.io/categories/%E7%BB%98%E7%94%BB%E7%9B%B8%E5%85%B3/"/>
    
    <category term="年度总结" scheme="http://azkoree.github.io/categories/%E7%BB%98%E7%94%BB%E7%9B%B8%E5%85%B3/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="绘画" scheme="http://azkoree.github.io/tags/%E7%BB%98%E7%94%BB/"/>
    
    <category term="年度总结" scheme="http://azkoree.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【转载】RGSS1脚本入门参考之二</title>
    <link href="http://azkoree.github.io/posts/d12553e4/"/>
    <id>http://azkoree.github.io/posts/d12553e4/</id>
    <published>2025-12-08T08:53:53.000Z</published>
    <updated>2025-12-21T14:46:14.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>本想在一篇文章里全部发完，但是它太长了编辑器有点卡，只能再开一篇</p><h1 id="第4章节：窗口的使用"><a href="#第4章节：窗口的使用" class="headerlink" title="第4章节：窗口的使用"></a>第4章节：窗口的使用</h1><p>接下来我们终于要学习窗口和精灵了，这我想也是大家特别想知道的。因为在这之前，我们都是同抽象的数据打交道，难免有些枯燥，那么在这一章，我们就要把我们自己脑中所想，全部展现在画面中。下面我们就开始吧。</p><h2 id="4-1-窗口的使用"><a href="#4-1-窗口的使用" class="headerlink" title="4.1  窗口的使用"></a>4.1  窗口的使用</h2><h3 id="4-1-1各种概念"><a href="#4-1-1各种概念" class="headerlink" title="4.1.1各种概念"></a>4.1.1各种概念</h3><p>在最开始，我们要明白一个窗口到底是什么，它到底有哪些属性。因此，我们必须要先介绍下面几个类。</p><p><strong>①rect：矩形的类</strong><br>顾名思义，这个类表示矩形，但这种东西是不能直接显示出来的。矩形是一种基本的类，它的作用在很多高级的类中体现尤其明显。矩形有四个属性，x坐标，y坐标，宽度，高度。其中x坐标和y坐标是相对而言的。</p><p><strong>②viewport：视口的类</strong><br>这个类是一个比较难理解的类，我在最开始也没明白这是什么东西。在屏幕上生成可见的对象都必须要指定视口viewport。简单说来，你面前有一堵墙，墙上有一个窗户可以看到墙对面的东西，那么这个窗户就可以类比成视口，你只能看到视口内有的东西，视口之外，即使有内容存在，你是看不到的。</p><p>我们举个简单的例子，大家打开脚本编辑器，在Window_BattleStatus中的initialize方法中，输入self.back_opacity &#x3D; 0<br><img src="/posts/d12553e4/4-1.png"></p><p>然后随便找一个640<em>480的战斗图片（注意大小是640</em>480），设置为一个地图的战斗图，然后进入战斗场景，画面会变成这样：<br><img src="/posts/d12553e4/4-2.png"></p><p>下面的640<em>160的矩形区域全部都是黑色的，这就说明图片显示不全，只有上半部分显示了出来。我们说过图片是640</em>480的，因此出现这种情况是我们视口的设置问题。打开Spriteset_Battle，我们在前面发现了这个：<br><img src="/posts/d12553e4/4-3.png"></p><p>我们看到生成战斗背景的视口是640<em>320，因此我们的640</em>480图片才显示不出来。</p><p>因此，无论图片是什么，生成的可视对象都必须在视口之内。</p><p>视口的提出为我们管理界面上的可显示元素提供方便，因为视口的移动，色相改变，闪烁只会影响视口内部的元素，而视口外部的元素不受影响。</p><p><strong>③bitmap：位图的类</strong></p><p>我们可以认为这一个类专门表示图片，但是要注意，Bitmap对象只是一个数据而已，并不能直接作为显示在屏幕中的对象。所以，bitmap是没有x坐标和y坐标这一属性的，这个要千万注意。但是，作为游戏的一种数据，在游戏运行的时候，必须要进入到游戏的内存中，RGSS里面有个高速缓存，专门用来保存这些临时的图片，用的时候就要在这里读取。因为高速缓存空间有限，因此我们要学会将不用的bitmap释放掉。</p><p>我们来看看bitmap里面都有什么方法。</p><p>dispose：释放位图，即将不用的位图从高速缓存中释放掉，我们在写程序时，必须有及时释放的好习惯，当然如果一个位图被频繁的使用，就不用释放了。</p><p>clear：清除位图全体，即将位图的内容变成一个空的“画布”</p><p>blt(x,y,src_bitmap,src_rect,opacity)：这个方法非常重要，大家一定要熟练掌握。这个方法的作用有点类似于两个位图之间的拷贝，意思就是将位图A指定矩形的内部内容拷贝到本位图中，放到指定坐标的位置。下图更加直观说明了这个事情。<br><img src="/posts/d12553e4/4-4.png"></p><p>这样大家应该理解了吧。</p><p>fill_rect(x,y,width,height,color)</p><p>fill_rect(rect,color)：上面两个都是在位图中绘制实心矩形，可以用矩形的各种信息，也可以直接把矩形放在参数中，要指定填充的颜色，利用这两个函数，我们可以在bitmap中绘制矩形，然后把它显示出来（要用到精灵）。朴素的HP条SP条就是这样描绘的。</p><p>draw_text(x,y,width,height,str,align)：在位图的指定区域描绘文字，align是对齐方式。这有点类似于Windows画图中的创建文字。这个大家也要熟练使用。F1中也说，这个处理要花费时间，尽量不要重复描绘字符串（意思就是只有在文字改变的时候才可描绘，比较省CPU，防止游戏卡顿）。</p><p>这些方法大家一定要熟练掌握，下面我们正式开始窗口的学习。</p><h3 id="4-1-2-窗口的基本知识-一般窗口的实现"><a href="#4-1-2-窗口的基本知识-一般窗口的实现" class="headerlink" title="4.1.2  窗口的基本知识 一般窗口的实现"></a>4.1.2  窗口的基本知识 一般窗口的实现</h3><p>脚本编辑器中，所有窗口的父类Window没有给出，我们也无法得知它的代码，但是我们打开F1，搜索Window，就会了解Window类的方法和属性，这对我们来说是个很好的参考。</p><p>窗口实际上是一种可以在屏幕上显示的图片，因此生成必须要指定视口。但是由于系统默认的缘故，不用额外加以设置。窗口以大量精灵构成，因此要有dispose方法。我们使用一个窗口完毕后，一定要把它释放掉。这个我们在介绍场景的时候会有说明。</p><p>F1中将各种方法已经说得很详细，这个我就不用多说。不过还是强调几个地方吧。</p><p>visible是可见与否的属性，如果你已经生成了一个窗口，但是不想显示它，就要用到visible属性，注意，隐藏不意味着释放。</p><p>active是活动状态属性，主要出现在有光标的窗口中，处于活动状态的窗口可以接受命令，进行光标闪烁等，游戏不能同时处理2个以上活动的窗口（你没见过按一下方向键两个窗口跟着一起变的吧？），因此同一个场景中，活动的窗口至多1个。</p><p>ox,oy是窗口内容原点的坐标，在这里我们可以把窗口看作一个小小的视口，里面的内容只能通过窗口显示出来。</p><p>注意：游戏默认窗口内容显示的视口是窗口上下左右边界向内16个像素，因此窗口实际内容和窗口边界总有16个像素的间隔，这个就尽量不要更改了。</p><p>作为所有Window的父类，Window里面可用的方法很少，我们来看看真正能作为显示窗口类的Window_Base：</p><p>先看initialize部分：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">x, y, width, height</span>)</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable">@windowskin_name</span> = <span class="variable">$game_system</span>.windowskin_name</span><br><span class="line">    <span class="variable language_">self</span>.windowskin = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.windowskin(<span class="variable">@windowskin_name</span>)</span><br><span class="line">    <span class="variable language_">self</span>.x = x</span><br><span class="line">    <span class="variable language_">self</span>.y = y</span><br><span class="line">    <span class="variable language_">self</span>.width = width</span><br><span class="line">    <span class="variable language_">self</span>.height = height</span><br><span class="line">    <span class="variable language_">self</span>.z = <span class="number">100</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里，我们生成一个窗口对象要指定它的位置和大小，并且设定窗口外观（这里默认是数据库的窗口外观），最后是z坐标，窗口的高度。</p><p>紧接着后面是个释放的方法，重定义：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dispose</span></span><br><span class="line">    <span class="comment"># 如果窗口的内容已经被设置就被释放</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.contents != <span class="literal">nil</span></span><br><span class="line">      <span class="variable language_">self</span>.contents.dispose</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="variable language_">super</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这里我们看到，对窗口释放同时也释放了作为窗口内容显示的位图，这样的好处是让我们的操作变得简单。例如写@a.dispose这样的语句，不但释放了窗口本身，也释放了窗口内容位图，一举两得。</p><p>后面是定义获取各种颜色的方法，这我就不多说了。</p><p>刷新update：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span></span><br><span class="line">    <span class="variable language_">super</span></span><br><span class="line">    <span class="comment"># 如果窗口的外关被变更了、再设置</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$game_system</span>.windowskin_name != <span class="variable">@windowskin_name</span></span><br><span class="line">      <span class="variable">@windowskin_name</span> = <span class="variable">$game_system</span>.windowskin_name</span><br><span class="line">      <span class="variable language_">self</span>.windowskin = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.windowskin(<span class="variable">@windowskin_name</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个update方法是刷新窗口，在RGSS中，有刷新作用的方法，原则上1帧调用一次，这个一定要注意。我们看到Window_Base的刷新很简单，就是要判定窗口外观的改变，并没有涉及内容的处理。因此我们在描绘内容时，尽量不要刷新它，我们刚才说到了draw_text需要花费时间，因此要避免每1帧都重新描绘文字。</p><p>下面则是一些基本的描绘：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_actor_graphic</span>(<span class="params">actor, x, y</span>)</span><br><span class="line">    bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.character(actor.character_name, actor.character_hue)</span><br><span class="line">    cw = bitmap.width / <span class="number">4</span></span><br><span class="line">    ch = bitmap.height / <span class="number">4</span></span><br><span class="line">    src_rect = <span class="title class_">Rect</span>.new(<span class="number">0</span>, <span class="number">0</span>, cw, ch)</span><br><span class="line">    <span class="variable language_">self</span>.contents.blt(x - cw / <span class="number">2</span>, y - ch, bitmap, src_rect)</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>角色图形的描绘，有3个参数，角色，描绘x坐标，描绘y坐标。</p><p>第二行是取得角色的位图，把它存储在高速缓存中。用的模块方法RPG::Cache，这个大家自行F1就好。然后是设定显示的内容，我们不能把整个图片显示出来，只需要显示左上角那个正脸的图就可以了，因此后面3行全部在设置截取图片的位置，随后，用blt方法，把截取的位置原封不动传送到self.contents中，window的contents就是表示窗口内容的位图，这恰恰就是blt完成的工作：把一个位图里面指定位置内容传给另一个位图中。在窗口中描绘图片就是这么简单。</p><p>下面我们再来看一个描绘文字的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_actor_hp</span>(<span class="params">actor, x, y, width = <span class="number">144</span></span>)</span><br><span class="line">    <span class="comment"># 描绘字符串 &quot;HP&quot;</span></span><br><span class="line">    <span class="variable language_">self</span>.contents.font.color = system_color</span><br><span class="line">    <span class="variable language_">self</span>.contents.draw_text(x, y, <span class="number">32</span>, <span class="number">32</span>, <span class="variable">$data_system</span>.words.hp)</span><br><span class="line">    <span class="comment"># 计算描绘 MaxHP 所需的空间 </span></span><br><span class="line">    <span class="keyword">if</span> width - <span class="number">32</span> &gt;= <span class="number">108</span></span><br><span class="line">      hp_x = x + width - <span class="number">108</span></span><br><span class="line">      flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">elsif</span> width - <span class="number">32</span> &gt;= <span class="number">48</span></span><br><span class="line">      hp_x = x + width - <span class="number">48</span></span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 描绘 HP</span></span><br><span class="line">    <span class="variable language_">self</span>.contents.font.color = actor.hp == <span class="number">0</span> ? knockout_color :</span><br><span class="line">      actor.hp &lt;= actor.maxhp / <span class="number">4</span> ? crisis_color : normal_color</span><br><span class="line">    <span class="variable language_">self</span>.contents.draw_text(hp_x, y, <span class="number">48</span>, <span class="number">32</span>, actor.hp.to_s, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 描绘 MaxHP</span></span><br><span class="line">    <span class="keyword">if</span> flag</span><br><span class="line">      <span class="variable language_">self</span>.contents.font.color = normal_color</span><br><span class="line">      <span class="variable language_">self</span>.contents.draw_text(hp_x + <span class="number">48</span>, y, <span class="number">12</span>, <span class="number">32</span>, <span class="string">&quot;/&quot;</span>, <span class="number">1</span>)</span><br><span class="line">      <span class="variable language_">self</span>.contents.draw_text(hp_x + <span class="number">60</span>, y, <span class="number">48</span>, <span class="number">32</span>, actor.maxhp.to_s)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>描绘角色HP。这里面参数多了一个宽度width，大家注意观察就可以发现，在菜单中描绘HP，是有最大HP的，在战斗中则没有，就是由于二者宽度不同导致的。后面的draw_text大家看看，基本上都会用。在这里提示一下，draw_text能描绘字符串，而不能描绘数字本身，因此draw_text(0, 0, 32, 32, 250)这样来描绘数字250是行不通的，Object类有个方法叫做to_s，把本身转换为字符串，因此要写250.to_s，这样等同于”250”。</p><p>另外，很多人被那些坐标还有宽度设置困扰，总也描绘不到合适的位置。这个其实也比较好解决，整个画面是640*480的，简单进行一些运算就会知道各种位置。还有，在窗口中进行的x,y都是指相对窗口内容位图的原点位置，并不是屏幕的位置，这个大家要注意。游戏默认字的高度是24个像素，一行的高度是32个像素，因此，如果5个默认大小的字连起来时，长度就是120（一个汉字的宽度&#x3D;2个英文字母的宽度），因此根据这个就可以设定描绘文字矩形的宽度了。最后要注意，draw_text是不能换行的，如果文字太长，它会一直描绘下去，可能会出边界。</p><p>有了这些知识，我们就可以来刻画一个最基本的窗口了。下面来小小测试一下。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span>_Test &lt; <span class="title class_">Window</span>_Base</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable language_">super</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">196</span>,<span class="number">64</span>)</span><br><span class="line">    <span class="variable language_">self</span>.contents = <span class="title class_">Bitmap</span>.new(width – <span class="number">32</span>, height - <span class="number">32</span>)</span><br><span class="line">    refresh</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">refresh</span></span><br><span class="line">    <span class="variable language_">self</span>.contents.clear</span><br><span class="line">    <span class="variable language_">self</span>.contents.draw_text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">144</span>,<span class="number">32</span>,”<span class="variable constant_">RMXP</span> is good”)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这样一个简单的窗口就定义好了。</p><p>但是这样是无法在屏幕上显示的，要让它显示出来，通常要借助场景Scene的帮助。</p><p>我们先学一点后面的东西，让我们的窗口显示出来。</p><p>在Scene_Map的main函数里面添加这样的语句：<br><img src="/posts/d12553e4/4-5.png"></p><p>然后再运行一下。效果如图。</p><p><img src="/posts/d12553e4/4-6.png"></p><p>在这里我们改动了Scene_Map脚本，但是也很简单，先创建一个窗口，在场景结束后再释放它，就是这样。</p><p>但是现在我们生成的窗口内容不能自动变化，如果我们要生成一个内容可能变化的窗口，这样就不行了。比方说，我们要在地图上显示角色的金钱，但是如果通过事件增加了队伍的金钱，窗口的内容是没有变化的。这就需要我们对update进行下改装，如果内容变更了，就重新描绘内容。我们知道draw_text是不适合反复调用的，因此我们只有在需要的时候，才能重新描绘窗口内容。首先要在refresh方法加上</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@gold</span> = <span class="variable">$game_party</span>.gold</span><br></pre></td></tr></table></figure><p>然后我们修改update方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span></span><br><span class="line">  <span class="variable language_">super</span></span><br><span class="line">  <span class="keyword">if</span> <span class="variable">$game_party</span>.gold != <span class="variable">@gold</span></span><br><span class="line">    refresh</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里，我们可以设置一个不公开的变量@gold，表示当前窗口描绘的金钱数量。然后对update进行重定义，让它能自动检查内容的变化。当然，我们也要对场景脚本进行改变，场景脚本里面有个update方法，在里面，我们加入对窗口的刷新@a.update，在这里我就不给出所有的代码了，作为练习，希望读者能写出一个在地图上显示金钱的窗口。</p><p>当然，这样简单的窗口，我们还是有方法能判断内容是否变更的，但是对于复杂的窗口，我们就无法判断了，因此，我们还需要掌握其他方法。</p><h3 id="4-1-3-滚动窗口的实现"><a href="#4-1-3-滚动窗口的实现" class="headerlink" title="4.1.3  滚动窗口的实现"></a>4.1.3  滚动窗口的实现</h3><p>下面我们学习如何使用滚动窗口。滚动窗口要用Window_Selectable。</p><p>打开这个脚本，我们发现它是Window_Base的子类。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 定义实例变量</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:index</span>                    <span class="comment"># 光标位置</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:help_window</span>              <span class="comment"># 帮助窗口</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 初始化对像</span></span><br><span class="line">  <span class="comment">#     x      : 窗口的 X 坐标</span></span><br><span class="line">  <span class="comment">#     y      : 窗口的 Y 坐标</span></span><br><span class="line">  <span class="comment">#     width  : 窗口的宽</span></span><br><span class="line">  <span class="comment">#     height : 窗口的高</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">x, y, width, height</span>)</span><br><span class="line">    <span class="variable language_">super</span>(x, y, width, height)</span><br><span class="line">    <span class="variable">@item_max</span> = <span class="number">1</span></span><br><span class="line">    <span class="variable">@column_max</span> = <span class="number">1</span></span><br><span class="line">    <span class="variable">@index</span> = -<span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里多了两个属性，光标位置（索引）和帮助窗口。考虑到很多滚动窗口（比方说物品和技能窗口）都要关联帮助窗口，因此需要设置这个属性。</p><p>初始化也没什么特别的，多了2个内部的实变量@item_max和@colunm_max，分别是描绘项目的最大值和描绘列数的最大值。</p><p>继续向下看，里面有计算窗口项目位置的各种方法。包括开头行，一页的最大项目数，一页的最大行数，都非常简单，这里就不说了。</p><p>我们在这里看到，RMXP里面默认一行的高度是32，也就是说，上面的所有设置位置的方法，都是按照这个标准进行的。当然，这个功能并不完善，我们可以对Window_Selectable进行修改，让它能显示任意行高的项目。</p><p>然后就是对输入的处理和光标矩形的更新，这里简单看看就可以了，不能完全理解也没有关系，只要记住这是干什么用的就好了。另外，Window_Selectable里面并没有给出光标明灭变化的方法，那个是在Window中定义的，只是我们看不到而已。</p><p>下面我们以Window_Item为例，来看看滚动窗口该怎样制作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span>_Item &lt; <span class="title class_">Window</span>_Selectable</span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 初始化对像</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable language_">super</span>(<span class="number">0</span>, <span class="number">64</span>, <span class="number">640</span>, <span class="number">416</span>)</span><br><span class="line">    <span class="variable">@column_max</span> = <span class="number">2</span></span><br><span class="line">    refresh</span><br><span class="line">    <span class="variable language_">self</span>.index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 战斗中的情况下将窗口移至中央并将其半透明化</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$game_temp</span>.in_battle</span><br><span class="line">      <span class="variable language_">self</span>.y = <span class="number">64</span></span><br><span class="line">      <span class="variable language_">self</span>.height = <span class="number">256</span></span><br><span class="line">      <span class="variable language_">self</span>.back_opacity = <span class="number">160</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 获取物品</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">item</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">@data</span>[<span class="variable language_">self</span>.index]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 刷新</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">refresh</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.contents != <span class="literal">nil</span></span><br><span class="line">      <span class="variable language_">self</span>.contents.dispose</span><br><span class="line">      <span class="variable language_">self</span>.contents = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="variable">@data</span> = []</span><br><span class="line">    <span class="comment"># 添加项目</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="variable">$data_items</span>.size</span><br><span class="line">      <span class="keyword">if</span> <span class="variable">$game_party</span>.item_number(i) &gt; <span class="number">0</span></span><br><span class="line">        <span class="variable">@data</span>.push(<span class="variable">$data_items</span>[i])</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 在战斗中以外添加武器、防具</span></span><br><span class="line">    <span class="keyword">unless</span> <span class="variable">$game_temp</span>.in_battle</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="variable">$data_weapons</span>.size</span><br><span class="line">        <span class="keyword">if</span> <span class="variable">$game_party</span>.weapon_number(i) &gt; <span class="number">0</span></span><br><span class="line">          <span class="variable">@data</span>.push(<span class="variable">$data_weapons</span>[i])</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="variable">$data_armors</span>.size</span><br><span class="line">        <span class="keyword">if</span> <span class="variable">$game_party</span>.armor_number(i) &gt; <span class="number">0</span></span><br><span class="line">          <span class="variable">@data</span>.push(<span class="variable">$data_armors</span>[i])</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 如果项目数不是 0 就生成位图、重新描绘全部项目</span></span><br><span class="line">    <span class="variable">@item_max</span> = <span class="variable">@data</span>.size</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@item_max</span> &gt; <span class="number">0</span></span><br><span class="line">      <span class="variable language_">self</span>.contents = <span class="title class_">Bitmap</span>.new(width - <span class="number">32</span>, row_max * <span class="number">32</span>)</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="variable">@item_max</span></span><br><span class="line">        draw_item(i)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 描绘项目</span></span><br><span class="line">  <span class="comment">#     index : 项目编号</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">draw_item</span>(<span class="params">index</span>)</span><br><span class="line">    item = <span class="variable">@data</span>[index]</span><br><span class="line">    <span class="keyword">case</span> item</span><br><span class="line">    <span class="keyword">when</span> <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Item</span></span><br><span class="line">      number = <span class="variable">$game_party</span>.item_number(item.id)</span><br><span class="line">    <span class="keyword">when</span> <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Weapon</span></span><br><span class="line">      number = <span class="variable">$game_party</span>.weapon_number(item.id)</span><br><span class="line">    <span class="keyword">when</span> <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Armor</span></span><br><span class="line">      number = <span class="variable">$game_party</span>.armor_number(item.id)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> item.is_a?(<span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Item</span>) <span class="keyword">and</span></span><br><span class="line">       <span class="variable">$game_party</span>.item_can_use?(item.id)</span><br><span class="line">      <span class="variable language_">self</span>.contents.font.color = normal_color</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="variable language_">self</span>.contents.font.color = disabled_color</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x = <span class="number">4</span> + index % <span class="number">2</span> * (<span class="number">288</span> + <span class="number">32</span>)</span><br><span class="line">    y = index / <span class="number">2</span> * <span class="number">32</span></span><br><span class="line">    rect = <span class="title class_">Rect</span>.new(x, y, <span class="variable language_">self</span>.width / <span class="variable">@column_max</span> - <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="variable language_">self</span>.contents.fill_rect(rect, <span class="title class_">Color</span>.new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.icon(item.icon_name)</span><br><span class="line">    opacity = <span class="variable language_">self</span>.contents.font.color == normal_color ? <span class="number">255</span> : <span class="number">128</span></span><br><span class="line">    <span class="variable language_">self</span>.contents.blt(x, y + <span class="number">4</span>, bitmap, <span class="title class_">Rect</span>.new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">24</span>), opacity)</span><br><span class="line">    <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">28</span>, y, <span class="number">212</span>, <span class="number">32</span>, item.name, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">240</span>, y, <span class="number">16</span>, <span class="number">32</span>, <span class="string">&quot;:&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">256</span>, y, <span class="number">24</span>, <span class="number">32</span>, number.to_s, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 刷新帮助文本</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">update_help</span></span><br><span class="line">    <span class="variable">@help_window</span>.set_text(<span class="variable language_">self</span>.item == <span class="literal">nil</span> ? <span class="string">&quot;&quot;</span> : <span class="variable language_">self</span>.item.description)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的初始化大家应该都没问题了，然后在这里定义了一个方法item，返回当前光标所指的物品。这个方法是必要的，原因我们要到场景的地方再解释。最后就是refresh方法，用来描绘窗口内的所有内容。</p><p>refresh里面大概分为以下几个层次。</p><p>首先释放窗口内容，这样做的目的是节省内存。考虑到窗口内容可能比较多，用self.contents.clear反倒不如释放再重新生成来得直接。而且描绘的最大项目数也会随着队伍中物品的变化而变化，如果设置固定的contents大小，不便于后面的处理。</p><p>接下来，就是制作窗口内容显示数据，把要显示的物品，武器，防具添加在一个@data数组里面，这是窗口的内部信息，没必要公开化。</p><p>接下来就是描绘窗口内容，在窗口存在项目的时候，一个个描绘。</p><p>描绘单个物品的方法draw_item(i)在后面定义，i指的是物品在@data中的索引，里面的结构清晰直观，大家看看就可以了。里面那个case语句希望大家熟练使用，case语句可以对实例进行类的判定，有了这个机制，写代码会比较方便。</p><p>最后，定义刷新帮助文本的方法（Window_Selectable里面已经有说明）。</p><p>怎么样？现在你可以写出有滚动光标的窗口了。</p><p>在这里我们留下一个小练习</p><p>就是我们刚才提到的，Window_Selectable默认每一行高度是32，能否对其进行优化，让用户创建自定义行高的窗口，并且和原来的脚本不发生冲突？</p><h2 id="4-2-一个滚动窗口的例子——真实商店"><a href="#4-2-一个滚动窗口的例子——真实商店" class="headerlink" title="4.2  一个滚动窗口的例子——真实商店"></a>4.2  一个滚动窗口的例子——真实商店</h2><p>不知道大家对之前介绍游戏对象的创建还有没有印象，在这一章节里面，我们要把商店的货物在窗口中描绘出来。如果忘了前面的内容的话，还请翻看下前面的帖子哦。</p><h3 id="4-2-1-准备工作"><a href="#4-2-1-准备工作" class="headerlink" title="4.2.1  准备工作"></a>4.2.1  准备工作</h3><p>我们想想这个窗口要描绘出什么。肯定要描绘各种物品，它的剩余量和它的价格。我们利用Window_Selectable的滚动功能，来实现滚动处理。</p><h3 id="4-2-2-Ruby代码"><a href="#4-2-2-Ruby代码" class="headerlink" title="4.2.2  Ruby代码"></a>4.2.2  Ruby代码</h3><p>有了上面的准备我们就可以写出代码了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span>_Visual_ShopBuy &lt; <span class="title class_">Window</span>_Selectable</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">shop_id</span>)</span><br><span class="line">    <span class="variable language_">super</span>(<span class="number">0</span>,<span class="number">128</span>,<span class="number">368</span>,<span class="number">480</span>-<span class="number">128</span>)</span><br><span class="line">    <span class="variable language_">self</span>.index = <span class="number">0</span></span><br><span class="line">    <span class="variable">@column_max</span> = <span class="number">1</span></span><br><span class="line">    <span class="variable">@shop_current</span> = <span class="variable">$game_visual_shops</span>[shop_id]</span><br><span class="line">    refresh</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 取得当前光标的物品</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">item</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">@data</span>[<span class="variable language_">self</span>.index]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">refresh</span></span><br><span class="line">    <span class="comment"># 内容被设置就释放，重新设置</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.contents != <span class="literal">nil</span></span><br><span class="line">      <span class="variable language_">self</span>.contents.dispose</span><br><span class="line">      <span class="variable language_">self</span>.contents = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 设置各种项目数据</span></span><br><span class="line">    <span class="variable">@data_items</span> = []</span><br><span class="line">    <span class="variable">@data_weapons</span> = []</span><br><span class="line">    <span class="variable">@data_armors</span> = []</span><br><span class="line">    <span class="comment"># 添加物品</span></span><br><span class="line">    <span class="keyword">for</span> item_id <span class="keyword">in</span> <span class="variable">@shop_current</span>.shop_goods_item.keys</span><br><span class="line">      <span class="variable">@data_items</span>.push(<span class="variable">$data_items</span>[item_id])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 排序按照物品ID</span></span><br><span class="line">    <span class="variable">@data_items</span>.sort!&#123;|<span class="params">a,b</span>| a.id – b.id&#125;</span><br><span class="line">    <span class="comment"># 添加武器</span></span><br><span class="line">    <span class="keyword">for</span> weapon_id <span class="keyword">in</span> <span class="variable">@shop_current</span>.shop_goods_weapon.keys</span><br><span class="line">      <span class="variable">@data_weapon</span>.push(<span class="variable">$data_weapons</span>[item_id])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 排序按照武器ID</span></span><br><span class="line">    <span class="variable">@data_weapons</span>.sort!&#123;|<span class="params">a,b</span>| a.id – b.id&#125;</span><br><span class="line">    <span class="comment"># 添加防具</span></span><br><span class="line">    <span class="keyword">for</span> armor_id <span class="keyword">in</span> <span class="variable">@shop_current</span>.shop_goods_armor.keys</span><br><span class="line">      <span class="variable">@data_armors</span>.push(<span class="variable">$data_armors</span>[item_id])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 排序按照物品ID</span></span><br><span class="line">    <span class="variable">@data_armors</span>.sort!&#123;|<span class="params">a,b</span>| a.id – b.id&#125;</span><br><span class="line">    <span class="comment"># 合并数组</span></span><br><span class="line">    <span class="variable">@data</span> = <span class="variable">@data_items</span> + <span class="variable">@data_weapons</span> + <span class="variable">@data_armors</span></span><br><span class="line">    <span class="variable">@item_max</span> = <span class="variable">@data</span>.size</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@item_max</span> &gt; <span class="number">0</span></span><br><span class="line">      <span class="variable language_">self</span>.contents = <span class="title class_">Bitmap</span>.new(width - <span class="number">32</span>, row_max * <span class="number">32</span>)</span><br><span class="line">      <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>…<span class="variable">@item_max</span></span><br><span class="line">        draw_item(index)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>由于窗口显示的是三种不同的物品，因此设置数据要花一些时间，但是基本思路跟描绘道具一样，因为商店里面的物品在变化，因此不要一开始就创建bitmap。</p><p>下面就是我们描绘物品的方法draw_item(index)了，注意，这个方法仍然定义在这个窗口内部，只不过是在这个帖子里面，写到外面了而已。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_item</span>(<span class="params">index</span>)</span><br><span class="line">  item = <span class="variable">@data</span>[index]</span><br><span class="line">  <span class="comment"># 取得持有数量和库存</span></span><br><span class="line">  <span class="keyword">case</span> item</span><br><span class="line">  <span class="keyword">when</span> <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Item</span></span><br><span class="line">    number = <span class="variable">$game_party</span>.item_number(item.id)</span><br><span class="line">    number_left = <span class="variable">@current_shop</span>.shop_goods_item[item.id]</span><br><span class="line">  <span class="keyword">when</span> <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Weapon</span></span><br><span class="line">    number = <span class="variable">$game_party</span>.weapon_number(item.id)</span><br><span class="line">    number_left = <span class="variable">@current_shop</span>.shop_goods_weapon[item.id]</span><br><span class="line">  <span class="keyword">when</span> <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Armor</span></span><br><span class="line">    number = <span class="variable">$game_party</span>.armor_number(item.id)</span><br><span class="line">    number_left = <span class="variable">@current_shop</span>.shop_goods_armor[item.id]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 设置颜色</span></span><br><span class="line">  <span class="keyword">if</span> item.price &lt;= <span class="variable">$game_party</span>.gold <span class="keyword">and</span> number &lt; <span class="number">99</span> <span class="keyword">and</span> number_left &gt; <span class="number">0</span></span><br><span class="line">    <span class="variable language_">self</span>.contents.font.color = normal_color</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="variable language_">self</span>.contents.font.color = disabled_color</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 开始描绘</span></span><br><span class="line">  x = <span class="number">4</span></span><br><span class="line">  y = index * <span class="number">32</span></span><br><span class="line">  rect = <span class="title class_">Rect</span>.new(x, y, <span class="variable language_">self</span>.width - <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">  <span class="variable language_">self</span>.contents.fill_rect(rect, <span class="title class_">Color</span>.new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">  bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.icon(item.icon_name)</span><br><span class="line">  opacity = <span class="variable language_">self</span>.contents.font.color == normal_color ? <span class="number">255</span> : <span class="number">128</span></span><br><span class="line">  <span class="variable language_">self</span>.contents.blt(x, y + <span class="number">4</span>, bitmap, <span class="title class_">Rect</span>.new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">24</span>), opacity)</span><br><span class="line">  <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">28</span>, y, <span class="number">168</span>, <span class="number">32</span>, item.name, <span class="number">0</span>)</span><br><span class="line">  <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">196</span>, y, <span class="number">80</span>, <span class="number">32</span>, item.price.to_s, <span class="number">2</span>)</span><br><span class="line">  <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">276</span>, y, <span class="number">48</span>, <span class="number">32</span>, “剩：”)</span><br><span class="line">  <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">308</span>, y, <span class="number">32</span>, <span class="number">32</span>, number_left.to_s, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>最后别忘了定义update_help，这样就大功告成了。不过，我们暂时无法检验它的对错，有兴趣的朋友可以利用场景来检验一下。</p><p><img src="/posts/d12553e4/4-7.png"><br>上图就是我们期待的效果，不过我们做的仅仅是左下角这个窗口哦，而且各种命令的处理还没有设定。</p><p>窗口的学习我们告一段落，接下来我们将要学习场景的使用。大家就敬请期待吧。</p><h1 id="第5章节：场景的使用（一）"><a href="#第5章节：场景的使用（一）" class="headerlink" title="第5章节：场景的使用（一）"></a>第5章节：场景的使用（一）</h1><p>场景的内容我们拆开来讲，第5章节主要说场景实现的一般过程，解读一些简单场景。第6章节我们主要是DIY一个我们自己想要的场景，并解读一个比较复杂的场景。</p><h2 id="5-1-精灵的使用"><a href="#5-1-精灵的使用" class="headerlink" title="5.1  精灵的使用"></a>5.1  精灵的使用</h2><p>这个本来应该在上一章节就应该讲到的，但是写上一章的时候一时脑抽，忘记了，因此在这里补上吧。</p><h3 id="5-1-1-精灵是什么"><a href="#5-1-1-精灵是什么" class="headerlink" title="5.1.1  精灵是什么"></a>5.1.1  精灵是什么</h3><p>所谓精灵(Sprite)，就是一种能在屏幕上显示各种可见对象的类。例如我们上一章节提到的窗口，还有游戏地图显示的实现，都是靠精灵完成的。另外，拥有动画播放效果的精灵是RPG模块下的Sprite类，也是精灵的一种。在这里，我们只需要学习一下精灵的最基本使用方法就可以了，相信大家一定会举一反三的。</p><h3 id="5-1-2-精灵的属性和方法"><a href="#5-1-2-精灵的属性和方法" class="headerlink" title="5.1.2  精灵的属性和方法"></a>5.1.2  精灵的属性和方法</h3><p>既然是一种特殊的类，那我们有必要了解精灵的使用方法。翻开F1，输入 Sprite 搜素，我们便看到了精灵（Sprite）的原型。</p><p>首先是类方法，生成一个新的精灵Sprite.new([viewport])，这里需要指定生成的视口Viewport，在第四章我们已经比较详细讲过视口的含义，和视口不同造成的显示区别。如果忘记了还请翻看19L的帖子哦。当然，这里viewport可以省略，这就默认精灵将直接显示在640*480的游戏窗口中。</p><p>接下来是各种属性和方法：</p><ul><li>dispose：方法，释放精灵，这个跟释放窗口的作用一样，如果一个精灵你不再使用它，那么需要把它从内存中释放。</li><li>bitmap：属性，作为精灵所显示的位图。注意，这个位图只是作为精灵显示的数据，实际显示在屏幕上的可能和这个位图略有不同。当然，在释放精灵之前，你有可能还要释放这个位图。释放的顺序则是先释放这个位图，再释放精灵本身。如果这个位图是利用Bitmap.new生成，则释放精灵之前，必须释放此位图；如果这个位图是利用RPG::Cache模块读取高速缓存，则可不必释放此位图。释放位图+精灵的代码一般写成这样：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sprite.bitmap.dispose</span><br><span class="line">sprite.dispose</span><br></pre></td></tr></table></figure><ul><li>src_rect：属性，传送位图的矩形，这个矩形的作用相当于“截取”原来位图的一部分，然后用精灵去显示。</li><li>visible：属性，精灵是否可见，如果想隐藏一个精灵而不是去释放它，请将visible置为false</li><li>ox,oy：属性，精灵原点坐标，我们可以把精灵占据的屏幕空间看作是一个矩形，默认这个原点在矩形的左上角。进行坐标变换和旋转的时候，需要参考这个原点。</li><li>zoom_x,zoom_y：属性，横向和纵向拉伸比例，浮点数。</li><li>angle：属性，表示逆时针旋转的角度，单位是度。</li></ul><p>我们可以用下面几个图片来表示精灵的各种属性：<br><img src="/5-1.PNG"></p><h3 id="5-1-3-精灵的具体使用"><a href="#5-1-3-精灵的具体使用" class="headerlink" title="5.1.3  精灵的具体使用"></a>5.1.3  精灵的具体使用</h3><p>了解了精灵的各种属性，现在我们可以使用它了。</p><p>我们要在屏幕上显示各种对象，需要借助Graphics模块。我们不必掌握Graphics的具体内容，在每个场景脚本中，已经在main方法中含有对Graphics模块的方法调用，在这里我们只需照葫芦画瓢就可以了。</p><p>核心的方法，是通过Graphics.update完成的，我们翻开Scene类的脚本，也可以看到这一句。</p><p>在Graphics.update之前，我们必须先生成一个精灵，然后Graphics会自动把它算在画面窗口里面显示的东西，然后通过调用update就可以显示出来了（同理，窗口对象也是，因为窗口本身就由大量精灵组成）。</p><p>简单显示一个图片的代码如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="title class_">Sprite</span>.new</span><br><span class="line">a.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.picture(<span class="string">&quot;123.png&quot;</span>) <span class="comment"># 这里输入Graphics/Pictures下文件名</span></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  <span class="title class_">Graphics</span>.update</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a.dispose <span class="comment"># 跳出循环后释放，注意，这里利用RPG::Cache载入位图，可不必释放bitmap</span></span><br></pre></td></tr></table></figure><p>总结下过程就是设置——显示——释放，是不是很简单？</p><h2 id="5-2-场景的简单使用"><a href="#5-2-场景的简单使用" class="headerlink" title="5.2  场景的简单使用"></a>5.2  场景的简单使用</h2><p>下面我们就要来学习场景的使用了，这也是最重要的技术之一，希望大家能好好掌握。所谓场景，就是把一些游戏对象（如窗口，精灵）组合起来的一个综合画面，每一个场景都可以看作是一个小系统。可以反馈信息，接收信息，跟玩家互动。下面我们就来具体解读一下。</p><h3 id="5-2-1-场景实现的一般步骤"><a href="#5-2-1-场景实现的一般步骤" class="headerlink" title="5.2.1  场景实现的一般步骤"></a>5.2.1  场景实现的一般步骤</h3><p>我们翻开任意一个场景脚本，都会发现开头有相似之处。先定义了main方法，有的是要定义initialize方法（有些则没有）。这个main方法是必要的，因为在前面我已经说过，Main组脚本就是不断调用场景的main方法来进行游戏的。而initialize是初始化场景类的某些具体的信息，而不是进行主处理，这点要记住。</p><p>一般的场景main方法主要分3部分。</p><p>设置（包括初始化）——（画面）刷新，更新——退出后的处理。</p><p>以Scene_Title为例，下面是它的main方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 主处理</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">main</span></span><br><span class="line">    <span class="comment"># 战斗测试的情况下</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$BTEST</span></span><br><span class="line">      battle_test</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 载入数据库</span></span><br><span class="line">    <span class="variable">$data_actors</span>        = load_data(<span class="string">&quot;Data/Actors.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_classes</span>       = load_data(<span class="string">&quot;Data/Classes.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_skills</span>        = load_data(<span class="string">&quot;Data/Skills.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_items</span>         = load_data(<span class="string">&quot;Data/Items.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_weapons</span>       = load_data(<span class="string">&quot;Data/Weapons.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_armors</span>        = load_data(<span class="string">&quot;Data/Armors.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_enemies</span>       = load_data(<span class="string">&quot;Data/Enemies.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_troops</span>        = load_data(<span class="string">&quot;Data/Troops.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_states</span>        = load_data(<span class="string">&quot;Data/States.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_animations</span>    = load_data(<span class="string">&quot;Data/Animations.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_tilesets</span>      = load_data(<span class="string">&quot;Data/Tilesets.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_common_events</span> = load_data(<span class="string">&quot;Data/CommonEvents.rxdata&quot;</span>)</span><br><span class="line">    <span class="variable">$data_system</span>        = load_data(<span class="string">&quot;Data/System.rxdata&quot;</span>)</span><br><span class="line">    <span class="comment"># 生成系统对像</span></span><br><span class="line">    <span class="variable">$game_system</span> = <span class="title class_">Game</span>_System.new</span><br><span class="line">    <span class="comment"># 生成标题图形</span></span><br><span class="line">    <span class="variable">@sprite</span> = <span class="title class_">Sprite</span>.new</span><br><span class="line">    <span class="variable">@sprite</span>.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(<span class="variable">$data_system</span>.title_name)</span><br><span class="line">    <span class="comment"># 生成命令窗口</span></span><br><span class="line">    s1 = <span class="string">&quot;新游戏&quot;</span></span><br><span class="line">    s2 = <span class="string">&quot;继续&quot;</span></span><br><span class="line">    s3 = <span class="string">&quot;退出&quot;</span></span><br><span class="line">    <span class="variable">@command_window</span> = <span class="title class_">Window</span>_Command.new(<span class="number">192</span>, [s1, s2, s3])</span><br><span class="line">    <span class="variable">@command_window</span>.back_opacity = <span class="number">160</span></span><br><span class="line">    <span class="variable">@command_window</span>.x = <span class="number">320</span> - <span class="variable">@command_window</span>.width / <span class="number">2</span></span><br><span class="line">    <span class="variable">@command_window</span>.y = <span class="number">288</span></span><br><span class="line">    <span class="comment"># 判定继续的有效性</span></span><br><span class="line">    <span class="comment"># 存档文件一个也不存在的时候也调查</span></span><br><span class="line">    <span class="comment"># 有效为 <span class="doctag">@continue</span>_enabled 为 true、无效为 false</span></span><br><span class="line">    <span class="variable">@continue_enabled</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span></span><br><span class="line">      <span class="keyword">if</span> <span class="title class_">FileTest</span>.exist?(<span class="string">&quot;Save<span class="subst">#&#123;i+<span class="number">1</span>&#125;</span>.rxdata&quot;</span>)</span><br><span class="line">        <span class="variable">@continue_enabled</span> = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 继续为有效的情况下、光标停止在继续上</span></span><br><span class="line">    <span class="comment"># 无效的情况下、继续的文字显示为灰色</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@continue_enabled</span></span><br><span class="line">      <span class="variable">@command_window</span>.index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="variable">@command_window</span>.disable_item(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 演奏标题 BGM</span></span><br><span class="line">    <span class="variable">$game_system</span>.bgm_play(<span class="variable">$data_system</span>.title_bgm)</span><br><span class="line">    <span class="comment"># 停止演奏 ME、BGS</span></span><br><span class="line">    <span class="title class_">Audio</span>.me_stop</span><br><span class="line">    <span class="title class_">Audio</span>.bgs_stop</span><br><span class="line">    <span class="comment"># 执行过渡</span></span><br><span class="line">    <span class="title class_">Graphics</span>.transition</span><br><span class="line">    <span class="comment"># 主循环</span></span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># 刷新游戏画面</span></span><br><span class="line">      <span class="title class_">Graphics</span>.update</span><br><span class="line">      <span class="comment"># 刷新输入信息</span></span><br><span class="line">      <span class="title class_">Input</span>.update</span><br><span class="line">      <span class="comment"># 刷新画面</span></span><br><span class="line">      update</span><br><span class="line">      <span class="comment"># 如果画面被切换就中断循环</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">$scene</span> != <span class="variable language_">self</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 装备过渡</span></span><br><span class="line">    <span class="title class_">Graphics</span>.freeze</span><br><span class="line">    <span class="comment"># 释放命令窗口</span></span><br><span class="line">    <span class="variable">@command_window</span>.dispose</span><br><span class="line">    <span class="comment"># 释放标题图形</span></span><br><span class="line">    <span class="variable">@sprite</span>.bitmap.dispose</span><br><span class="line">    <span class="variable">@sprite</span>.dispose</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们看到，在注释“准备过渡”之前，进行的都是一些设置的工作，比如载入数据库，生成各种图片和窗口，在设置完毕之后，准备过渡到画面状态（此时画面上什么也没有），然后接着是一个无限循环loop do，按照一定顺序刷新各种东西，在这里我们看到了Graphics.update，刷新游戏画面，然后是Input.update，这里Input也是内部模块，用来处理输入用的，最后是一个单独的update，这个其实是该场景内部的刷新方法，需要我们在后面进行追加定义。刷新完毕后，判断场景是否已经被切换，即$scene变量是否在update之后发生改变。如果改变，退出无限循环，场景结束，进行各种事后处理（各种释放和过渡）。</p><p>在这里，可能有些人注意到了，虽然这里的Sprite的位图是用RPG::Cache模块载入的，但是在释放精灵之前，仍然对此位图进行了释放操作。这似乎和我前面提到的释放原则不一致。在这里，我要仔细说明一下使用RPG::Cache模块的原则。首先，RPG::Cache模块存在的意义，就是将图片载入内存中，如果该图片需要重复被使用（或者被多个Sprite对象使用），那么将其放入缓存中可以节约内存，提高载入速度，所以RPG::Cache中的位图是可以不释放的。而对于一些使用频率较少的位图，则不必将其放入RPG::Cache中，或者是使用之后及时释放，以腾出更多空间来存储使用率更大的位图。</p><p>整个过程清晰明了，需要我们做的，就是丰富这个骨架的内容。</p><p>我们注意中间那个loop do的无限循环，原则上是1帧执行1次，因此里面放的方法都是定期需要重复执行的方法，这种方法通常我们命名为update（注意不是refresh），也就是说，放到这里的东西，都应该是我们需要反复刷新的，如果不需要反复刷新，则一般不要单独放进去（可以放到场景私有的update方法里，然后再进行判断）。</p><h3 id="5-2-2-场景的具体实现"><a href="#5-2-2-场景的具体实现" class="headerlink" title="5.2.2  场景的具体实现"></a>5.2.2  场景的具体实现</h3><pre><code>   接下来我们就可以解读一下场景的具体实现了。我们以Scene_Item为例，来具体说明一下。</code></pre><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 主处理</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">main</span></span><br><span class="line">    <span class="comment"># 生成帮助窗口、物品窗口</span></span><br><span class="line">    <span class="variable">@help_window</span> = <span class="title class_">Window</span>_Help.new</span><br><span class="line">    <span class="variable">@item_window</span> = <span class="title class_">Window</span>_Item.new</span><br><span class="line">    <span class="comment"># 关联帮助窗口</span></span><br><span class="line">    <span class="variable">@item_window</span>.help_window = <span class="variable">@help_window</span></span><br><span class="line">    <span class="comment"># 生成目标窗口 (设置为不可见・不活动)</span></span><br><span class="line">    <span class="variable">@target_window</span> = <span class="title class_">Window</span>_Target.new</span><br><span class="line">    <span class="variable">@target_window</span>.visible = <span class="literal">false</span></span><br><span class="line">    <span class="variable">@target_window</span>.active = <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 执行过度</span></span><br><span class="line">    <span class="title class_">Graphics</span>.transition</span><br><span class="line">    <span class="comment"># 主循环</span></span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># 刷新游戏画面</span></span><br><span class="line">      <span class="title class_">Graphics</span>.update</span><br><span class="line">      <span class="comment"># 刷新输入信息</span></span><br><span class="line">      <span class="title class_">Input</span>.update</span><br><span class="line">      <span class="comment"># 刷新画面</span></span><br><span class="line">      update</span><br><span class="line">      <span class="comment"># 如果画面切换就中断循环</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">$scene</span> != <span class="variable language_">self</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 装备过渡</span></span><br><span class="line">    <span class="title class_">Graphics</span>.freeze</span><br><span class="line">    <span class="comment"># 释放窗口</span></span><br><span class="line">    <span class="variable">@help_window</span>.dispose</span><br><span class="line">    <span class="variable">@item_window</span>.dispose</span><br><span class="line">    <span class="variable">@target_window</span>.dispose</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面是Scene_Item的main方法，主要生成了3个窗口，帮助窗口，物品窗口，目标窗口。而最初，目标窗口是不可见的（因为你还没使用某个道具），而帮助窗口和物品窗口是互相关联的，必须设置好。然后就可以过渡了，整个过程非常清晰。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span></span><br><span class="line">    <span class="comment"># 刷新窗口</span></span><br><span class="line">    <span class="variable">@help_window</span>.update</span><br><span class="line">    <span class="variable">@item_window</span>.update</span><br><span class="line">    <span class="variable">@target_window</span>.update</span><br><span class="line">    <span class="comment"># 物品窗口被激活的情况下: 调用 update_item</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@item_window</span>.active</span><br><span class="line">      update_item</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 目标窗口被激活的情况下: 调用 update_target</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@target_window</span>.active</span><br><span class="line">      update_target</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这就是我们在上面说的，场景私有update方法的定义，这个方法定义非常重要，这决定了你的场景是否能和玩家互动。</p><p>一般来说，update方法分为2部分，一是自动刷新，即无论玩家有没有操作，都必须刷新的对象；二是条件刷新，当玩家有一定操作时，进行刷新相应对象。执行的顺序是先自动刷新，再条件刷新，这个顺序不能变。我们在这里可以设置一个输入等待的机制，必须等待固定时间，才能接受玩家的输入（注意，自动刷新是一直进行的）。这种情况出现的时候有很多，比方说玩家按了一个按键，画面进行某种变换，变化持续时间是1秒（40帧），你不希望在画面变化的时候接受玩家的其他输入，这时候就有必要设置输入等待了。比方说  这里，我们先要在main方法内设置一个内部变量@wait_count，并初始化为0，表示等待计数的时间。然后在update的条件刷新之前，放上以下代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable">@wait_count</span> &gt; <span class="number">0</span></span><br><span class="line">  <span class="variable">@wait_count</span> -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这就表示在等待时间不为0的情况下，将等待时间减去1，注意，update方法是1帧调用一次，@wait_count等于多少，就意味着要等待多少帧。随后立即结束update方法，注意，那个return不能少，这个return是避免update进行条件更新的，因此在@wait_count大于0的情况下，系统无法接受玩家的输入。这个问题就被我们解决了。</p><p>而在这里，条件刷新有两个地方，如果物品窗口被激活就调用update_item方法，如果目标窗口被激活就调用update_target方法。这个必须分开设置，因为不同状态下刷新的规则肯定是不一样的。另外还需要注意每一个分支下面，要有return，否则很可能出现在同一次update下进行两种以上更新的情况。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 刷新画面 (物品窗口被激活的情况下)</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">update_item</span></span><br><span class="line">    <span class="comment"># 按下 B 键的情况下</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title class_">Input</span>.trigger?(<span class="title class_">Input</span><span class="symbol">:</span><span class="symbol">:B</span>)</span><br><span class="line">      <span class="comment"># 演奏取消 SE</span></span><br><span class="line">      <span class="variable">$game_system</span>.se_play(<span class="variable">$data_system</span>.cancel_se)</span><br><span class="line">      <span class="comment"># 切换到菜单画面</span></span><br><span class="line">      <span class="variable">$scene</span> = <span class="title class_">Scene</span>_Menu.new(<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 按下 C 键的情况下</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title class_">Input</span>.trigger?(<span class="title class_">Input</span><span class="symbol">:</span><span class="symbol">:C</span>)</span><br><span class="line">      <span class="comment"># 获取物品窗口当前选中的物品数据</span></span><br><span class="line">      <span class="variable">@item</span> = <span class="variable">@item_window</span>.item</span><br><span class="line">      <span class="comment"># 不使用物品的情况下</span></span><br><span class="line">      <span class="keyword">unless</span> <span class="variable">@item</span>.is_a?(<span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Item</span>)</span><br><span class="line">        <span class="comment"># 演奏冻结 SE</span></span><br><span class="line">        <span class="variable">$game_system</span>.se_play(<span class="variable">$data_system</span>.buzzer_se)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="comment"># 不能使用的情况下</span></span><br><span class="line">      <span class="keyword">unless</span> <span class="variable">$game_party</span>.item_can_use?(<span class="variable">@item</span>.id)</span><br><span class="line">        <span class="comment"># 演奏冻结 SE</span></span><br><span class="line">        <span class="variable">$game_system</span>.se_play(<span class="variable">$data_system</span>.buzzer_se)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="comment"># 演奏确定 SE</span></span><br><span class="line">      <span class="variable">$game_system</span>.se_play(<span class="variable">$data_system</span>.decision_se)</span><br><span class="line">      <span class="comment"># 效果范围是我方的情况下</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">@item</span>.scope &gt;= <span class="number">3</span></span><br><span class="line">        <span class="comment"># 激活目标窗口</span></span><br><span class="line">        <span class="variable">@item_window</span>.active = <span class="literal">false</span></span><br><span class="line">        <span class="variable">@target_window</span>.x = (<span class="variable">@item_window</span>.index + <span class="number">1</span>) % <span class="number">2</span> * <span class="number">304</span></span><br><span class="line">        <span class="variable">@target_window</span>.visible = <span class="literal">true</span></span><br><span class="line">        <span class="variable">@target_window</span>.active = <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 设置效果范围 (单体/全体) 的对应光标位置</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable">@item</span>.scope == <span class="number">4</span> |<span class="params"></span>| <span class="variable">@item</span>.scope == <span class="number">6</span></span><br><span class="line">          <span class="variable">@target_window</span>.index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="variable">@target_window</span>.index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="comment"># 效果在我方以外的情况下</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># 公共事件 ID 有效的情况下</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable">@item</span>.common_event_id &gt; <span class="number">0</span></span><br><span class="line">          <span class="comment"># 预约调用公共事件</span></span><br><span class="line">          <span class="variable">$game_temp</span>.common_event_id = <span class="variable">@item</span>.common_event_id</span><br><span class="line">          <span class="comment"># 演奏物品使用时的 SE</span></span><br><span class="line">          <span class="variable">$game_system</span>.se_play(<span class="variable">@item</span>.menu_se)</span><br><span class="line">          <span class="comment"># 消耗品的情况下</span></span><br><span class="line">          <span class="keyword">if</span> <span class="variable">@item</span>.consumable</span><br><span class="line">            <span class="comment"># 使用的物品数减 1</span></span><br><span class="line">            <span class="variable">$game_party</span>.lose_item(<span class="variable">@item</span>.id, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 再描绘物品窗口的项目</span></span><br><span class="line">            <span class="variable">@item_window</span>.draw_item(<span class="variable">@item_window</span>.index)</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">          <span class="comment"># 切换到地图画面</span></span><br><span class="line">          <span class="variable">$scene</span> = <span class="title class_">Scene</span>_Map.new</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这里我们终于看到了对各种输入的处理，知道了物品的使用效果和消耗，都是在update及其子方法里面实现的。注意，Window_Selectable中光标的移动不在此中，Window_Selectable内部的update上。这里大家粗略看一下就能明白大意，我就不多做介绍了。在这里注意refresh方法的调用，我们调用refresh方法，只是在窗口需要刷新的时候才进行调用。如果窗口需要刷新的原因是我们输入了某种指令，那么在指令的最后，一定要重新刷新窗口，否则一般不进行窗口内容再描绘的处理（因为这样太消耗时间了）。</p><p>最后我们说一下带initialize方法的场景类。Scene类可以不用带initialize方法，但是在某些场合下，我们需要设置initialize方法。</p><p>比方说Scene_Menu场景，就有initialize方法，这里的initialize方法非常简单。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">menu_index</span>)</span><br><span class="line">  <span class="variable">@menu_index</span> = menu_index</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这是设置菜单初始光标位置，考虑到从不同场景退回Scene_Menu，菜单光标位置不同，才考虑加的这个内部变量。比方说从Scene_Item返回，要写$scene &#x3D; Scene_Menu.new(0)，这是因为物品选项在菜单的第一个位置上。其余的同理。</p><p>场景类的基本知识就到这里，在第6章节，我们要亲自DIY一个场景，并解读一些复杂场景，大家敬请期待吧。</p><h1 id="第6章节：场景的使用（二）"><a href="#第6章节：场景的使用（二）" class="headerlink" title="第6章节：场景的使用（二）"></a>第6章节：场景的使用（二）</h1><p>说正题前，扯一点题外话。好久没填坑了，眼睁睁看着帖子沉了不太好啊，不过貌似这个教程贴没什么回复呢，偶好伤心啊，我的水平就这么差么，啊啊啊……最近忙得要死，也没时间写了，明天就有一门考试等着呢……</p><h2 id="6-1-朴素的任务脚本"><a href="#6-1-朴素的任务脚本" class="headerlink" title="6.1  朴素的任务脚本"></a>6.1  朴素的任务脚本</h2><p>在我们真正开始这部分内容，让我们回顾一下场景制作的一般步骤。首先是定义main方法，第一步是建立各种可见的对象，然后进行主循环，最后进行释放dispose操作。其中，主循环要进行三步刷新，Graphics.update，Input.update，update，其中，我们要重点定义update的内容，包括自动更新和对各种输入的反应。那么我们想要写一个脚本时，先判断需不需要一个独立的窗口来处理这个问题。对于我们今天的“朴素的任务脚本”来说，就比较适合用一个场景来描述任务。</p><h3 id="6-1-1-游戏对象的设计：任务对象"><a href="#6-1-1-游戏对象的设计：任务对象" class="headerlink" title="6.1.1  游戏对象的设计：任务对象"></a>6.1.1  游戏对象的设计：任务对象</h3><p>在6R中，已经有各色各类的任务脚本，本人见到的第一个任务脚本，是采用的物品——武器——道具描述法，即把任务数据存放在RMXP内部数据库中。这样做的好处就是方便不会用脚本的人来设计任务，但缺点就是它把任务这一和物品，武器，道具不太相同的游戏对象混在一起了，因此，我们采取定义新对象的方式，考虑这是一种RPG内部数据，因此也把它定义在RPG模块下为好。</p><p>一个任务应该具有的基本属性有：名称，内容。当然，内容你可以再扩展很多很多。比方说内容可以分为具体描述，难度，奖励，目标的人物或地点或物品，结算任务的地点和人物等等。在这里，我们只挑选几个有代表性的定义就OK。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="variable constant_">RPG</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Journal</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:name</span>           <span class="comment"># 名称(String)</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:description</span>       <span class="comment"># 描述(String 数组)</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:difficulty</span>        <span class="comment"># 难度(Integer)</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:reward_gold</span>     <span class="comment"># 奖励金钱(Integer)</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:reward_items</span>    <span class="comment"># 奖励物品(数组，内部元素依然是数组，格式为[物品ID, 物品数量])</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:reward_weapons</span>  <span class="comment"># 奖励武器，格式同上</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:reward_armors</span>    <span class="comment"># 奖励防具，格式同上</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">      <span class="variable">@name</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="variable">@description</span> = [<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>]</span><br><span class="line">      <span class="variable">@difficulty</span> = <span class="number">0</span></span><br><span class="line">      <span class="variable">@reward_gold</span> = <span class="number">0</span></span><br><span class="line">      <span class="variable">@reward_items</span> = []</span><br><span class="line">      <span class="variable">@reward_weapons</span> = []</span><br><span class="line">      <span class="variable">@reward_armors</span> = []</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这里，我们初始化的时候，并没有急着描述任务的内容，这个到后面的时候再写也不迟。每个属性后面都有注释，来说明是用什么样的结构来表示这个属性。这点在后面的initialize方法里面也能看出来。</p><p>注意，这里的@description表示一个含有三个字符串的数组，这是考虑到draw_text无法换行，而描述又比较多，写下三行会比较美观。难度@difficulty是自己定义的，可以有很多等级，在这里我们定义6个等级（0到5），当然，0级就是那种只要电脑不死机就能完成的任务，5级当然就是要花很大力气才能通关的任务。</p><p>当然，作为一种游戏的数据，地位和$data_items之类的应该相当，都应该在游戏刚打开的时候就被载入。但是，由于定义的性质不同，其他的数据早在你用RMXP之时，就已经安静地躺在data文件夹下，用的时候读取文件即可，但是我们新定义的RPG::Journal却不是这样，因此我们只能在游戏中处理它（会浪费一些时间，不过数据规模不大的话影响应该很小）。</p><p>和其他数据一样，我们用一个全局变量（其实是一个数组）$data_journals来表示所有任务的数据，为了和游戏内部统一，我们把$data_journals的0号单元置为nil，其余的都是RPG::Journal类的对象。我们需要定义一下方法，这个方法我们定义为RPG模块的模块方法(module function)：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="variable constant_">RPG</span></span><br><span class="line">  <span class="comment"># 定义模块方法 get_journal_data</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.get_journal_data</span><br><span class="line">    data = [<span class="literal">nil</span>]</span><br><span class="line">    <span class="comment"># 1号任务</span></span><br><span class="line">    journal = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Journal</span>.new</span><br><span class="line">    journal.name = <span class="string">&quot;第一个任务&quot;</span></span><br><span class="line">    journal.description[<span class="number">0</span>] = <span class="string">&quot;随便玩玩就可以啦&quot;</span></span><br><span class="line">    journal.difficulty = <span class="number">0</span></span><br><span class="line">    journal.reward_items = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">    data.push(journal)</span><br><span class="line">    <span class="comment"># 1号任务完毕</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这里，我们看到了，有关任务奖励的，其实是一个二维数组（金钱的除外），表示奖励，每一个大数组的元素又是一个含有2个元素的小数组，前面那个表示ID，后面那个表示数量。我们只需要模仿这个模式，逐个定义即可。最后那个return是必须的，以便$data_journals接受我们的返回值。完成这个方法后，一定要在Scene_Title相关载入数据的下面写上$data_journals &#x3D; RPG.get_journal_data，在这里就不再写代码示例了。有关多个任务数据的定义，直接复制上面代码中“1号任务——1号任务完毕”中间的部分，依次排在return data之前，就可以定义其他的任务，ID就是脚本编辑器中的顺序（建议用注释标明）。这样，我们的游戏对象就定义完成了。</p><p>不过，还有一个问题，就是如何保存队伍中当前的任务，要知道数据库中的任务和实际有的任务是不一样的（就像数据库有所有的道具，但是队伍中只含有一部分）。考虑到任务是队伍的一个属性，因此可以定义在Game_Party内部，当然也可以单独存放在别的位置里面。在这里我们用一种特殊的方法来表示，借助游戏变量$game_variables来存储。这是因为$game_variables是可以写到存档数据内部的，虽然这里存储着游戏中所有的自定义变量（默认是数值，就是事件编辑器里面的“变量操作”操作的变量），但是实际上可以存储任何东西。我们就用它来存储当前队伍的任务数据。我们选定一个变量ID，例如1号来保存我们的当前任务，考虑到任务只有两种状态（即接受和完成），我们只需要定义一个数组来保存当前所有任务的ID即可。具体实现方法就是在初始化游戏的时候（Scene_Title里面），写下$game_variables[1] &#x3D; []，来初始化当前任务内容，不过，1号变量在游戏中就不能作为它用了，这点要格外注意。</p><p><strong>第二版注：$game_variables是个筐，什么都可以往里装。虽然此话不假，但是这样做违反了脚本编写的一致性，现在更推荐将任务存储在Game_Party的内部。不过这样对教程的改动略大，因此第二版对此不加改动，希望大家注意。</strong></p><h3 id="6-1-2-任务的窗口描述"><a href="#6-1-2-任务的窗口描述" class="headerlink" title="6.1.2  任务的窗口描述"></a>6.1.2  任务的窗口描述</h3><p>有了这个，我们才能在窗口内描述任务的细节，以便让玩家更清楚了解情况。首先我们要知道，任务窗口大概分为两部分，一是描述所有当前的任务名称，二是描述任务细节。这个跟我们道具的显示是一样的，分为显示道具名字和说明。因此，我们要制作两个窗口为好。</p><p>首先是显示任务名字的部分：</p><p>回忆一下窗口的制作过程，是初始化——描绘(refresh)——刷新窗口（如果有需要的话），初始化做的工作是设置窗口位置和大小，refresh是描述窗口内容（不要重复刷新，很浪费时间）。</p><p>如果大家窗口已经使用熟练的话，应该很容易。这个窗口的描绘请参考Window_Item。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前任务的窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span>_Journal &lt; <span class="title class_">Window</span>_Selectable</span><br><span class="line">  <span class="comment"># 对象初始化</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable language_">super</span>(<span class="number">0</span>, <span class="number">64</span>, <span class="number">240</span>, <span class="number">416</span>)</span><br><span class="line">    <span class="variable language_">self</span>.index = <span class="number">0</span></span><br><span class="line">    refresh</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 取得当前光标选中的任务信息</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">journal</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">@data</span>[<span class="variable language_">self</span>.index]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 刷新</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">refresh</span></span><br><span class="line">    <span class="comment"># 如果内容被设置了就释放</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.contents != <span class="literal">nil</span></span><br><span class="line">      <span class="variable language_">self</span>.contents.dispose</span><br><span class="line">      <span class="variable language_">self</span>.contents = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="variable">@data</span> = []</span><br><span class="line">    <span class="comment"># 添加当前任务</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$game_variables</span>[<span class="variable constant_">JOURNAL</span>]</span><br><span class="line">      <span class="variable">@data</span>.push(<span class="variable">$data_journals</span>[i])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 取得最大项目数</span></span><br><span class="line">    <span class="variable">@item_max</span> = <span class="variable">$game_variables</span>[<span class="variable constant_">JOURNAL</span>].size</span><br><span class="line">    <span class="comment"># 最大项目数不为 0 就开始描绘</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@item_max</span> &gt; <span class="number">0</span></span><br><span class="line">      <span class="variable language_">self</span>.contents = <span class="title class_">Bitmap</span>.new(width - <span class="number">32</span>, <span class="variable">@item_max</span> * <span class="number">32</span>)</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="variable">@item_max</span></span><br><span class="line">        draw_item(i)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="variable language_">self</span>.contents = <span class="title class_">Bitmap</span>.new(width - <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">      <span class="variable language_">self</span>.contents.draw_text(<span class="number">4</span>, <span class="number">0</span>, width - <span class="number">36</span>, <span class="number">32</span>, <span class="string">&quot;无任务&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 描绘项目</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">draw_item</span>(<span class="params">i</span>)</span><br><span class="line">    x = <span class="number">4</span></span><br><span class="line">    y = i * <span class="number">32</span></span><br><span class="line">    bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.icon(<span class="string">&quot;Journal.png&quot;</span>)</span><br><span class="line">    name = <span class="variable">@data</span>[i].name</span><br><span class="line">    <span class="variable language_">self</span>.contents.blt(x, y, bitmap, <span class="title class_">Rect</span>.new(<span class="number">0</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">24</span>))</span><br><span class="line">    <span class="variable language_">self</span>.contents.draw_text(x+<span class="number">28</span>, y, width-x-<span class="number">36</span>-<span class="number">24</span>, <span class="number">32</span>, name)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这里，我们用一个常量JOURNAL来表示队伍中含有的任务数组在$game_variables里面存放的位置，当然可以随便更改。这个窗口是仿照了Window_Item脚本，没写太多注释，大家可以对比着看一下，都比较简单。</p><p>然后就是显示任务具体内容的窗口，这个用Window_Base生成就好，不过还是有些地方需要大家注意一下。首先大家要清楚，这个窗口是为了描述某个具体任务的，因此必须要有一个私有的实变量来保存当前描绘的任务，当然你不必将它设置为属性。还有一点就是关于描述任务奖励的，考虑到任务奖励种类比较多，为了美观，我们把它们合并在一起来描绘。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 描绘任务具体内容的窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span>_Journal_Contents &lt; <span class="title class_">Window</span>_Base</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable language_">super</span>(<span class="number">240</span>, <span class="number">64</span>, <span class="number">400</span>, <span class="number">416</span>)</span><br><span class="line">    <span class="variable language_">self</span>.contents = <span class="title class_">Bitmap</span>.new(width - <span class="number">32</span>, height - <span class="number">32</span>)</span><br><span class="line">    <span class="variable">@journal</span> = <span class="literal">nil</span></span><br><span class="line">    refresh</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 设置当前要描绘的任务</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">journal=</span>(<span class="params">journal</span>)</span><br><span class="line">    <span class="comment"># 如果任务和当前任务有差异</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@journal</span> != journal</span><br><span class="line">      <span class="variable">@journal</span> = journal</span><br><span class="line">      refresh</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">refresh</span></span><br><span class="line">    <span class="variable language_">self</span>.contents.clear</span><br><span class="line">    <span class="variable language_">self</span>.contents.font.size = <span class="number">18</span></span><br><span class="line">    <span class="variable language_">self</span>.contents.font.color = system_color</span><br><span class="line">    <span class="variable language_">self</span>.contents.draw_text(<span class="number">0</span>, <span class="number">0</span>, <span class="number">72</span>, <span class="number">24</span>, <span class="string">&quot;具体内容&quot;</span>)</span><br><span class="line">    <span class="variable language_">self</span>.contents.draw_text(<span class="number">0</span>, <span class="number">96</span>, <span class="number">36</span>, <span class="number">24</span>, <span class="string">&quot;难度&quot;</span>)</span><br><span class="line">    <span class="variable language_">self</span>.contents.draw_text(<span class="number">0</span>, <span class="number">144</span>, <span class="number">72</span>, <span class="number">24</span>, <span class="string">&quot;任务奖励&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@journal</span> != <span class="literal">nil</span></span><br><span class="line">      <span class="variable language_">self</span>.contents.font.color = normal_color</span><br><span class="line">      (<span class="number">0</span>..<span class="number">2</span>).each <span class="keyword">do</span> |<span class="params">i</span>|</span><br><span class="line">        <span class="variable language_">self</span>.contents.draw_text(<span class="number">0</span>, <span class="number">24</span> + <span class="number">24</span> * i, width - <span class="number">32</span>, <span class="number">24</span>, <span class="variable">@journal</span>.description[i])</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      diff = <span class="string">&quot;★&quot;</span> * <span class="variable">@journal</span>.difficulty + <span class="string">&quot;☆&quot;</span> * (<span class="number">5</span> - <span class="variable">@journal</span>.difficulty)</span><br><span class="line">      <span class="variable language_">self</span>.contents.draw_text(<span class="number">0</span>, <span class="number">120</span>, width - <span class="number">32</span>, <span class="number">24</span>, diff)</span><br><span class="line">      total = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">@journal</span>.reward_items</span><br><span class="line">        x = <span class="number">184</span> * (total % <span class="number">2</span>)</span><br><span class="line">        y = <span class="number">168</span> + <span class="number">24</span> * (total / <span class="number">2</span>)</span><br><span class="line">        name = <span class="variable">$data_items</span>[item[<span class="number">0</span>]].name</span><br><span class="line">        icon = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.icon(<span class="variable">$data_items</span>[item[<span class="number">0</span>]].icon_name)</span><br><span class="line">        number = item[<span class="number">1</span>]</span><br><span class="line">        <span class="variable language_">self</span>.contents.blt(x, y, icon, <span class="title class_">Rect</span>.new(<span class="number">0</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">24</span>))</span><br><span class="line">        <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">28</span>, y, <span class="number">126</span>, <span class="number">24</span>, name)</span><br><span class="line">        <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">28</span> + <span class="number">126</span>, y, <span class="number">30</span>, <span class="number">24</span>, number.to_s, <span class="number">2</span>)</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">@journal</span>.reward_weapons</span><br><span class="line">        x = <span class="number">184</span> * (total % <span class="number">2</span>)</span><br><span class="line">        y = <span class="number">168</span> + <span class="number">24</span> * (total / <span class="number">2</span>)</span><br><span class="line">        name = <span class="variable">$data_weapons</span>[item[<span class="number">0</span>]].name</span><br><span class="line">        icon = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.icon(<span class="variable">$data_weapons</span>[item[<span class="number">0</span>]].icon_name)</span><br><span class="line">        number = item[<span class="number">1</span>]</span><br><span class="line">        <span class="variable language_">self</span>.contents.blt(x, y, icon, <span class="title class_">Rect</span>.new(<span class="number">0</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">24</span>))</span><br><span class="line">        <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">28</span>, y, <span class="number">126</span>, <span class="number">24</span>, name)</span><br><span class="line">        <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">28</span> + <span class="number">126</span>, y, <span class="number">30</span>, <span class="number">24</span>, number.to_s, <span class="number">2</span>)</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">@journal</span>.reward_armors</span><br><span class="line">        x = <span class="number">184</span> * (total % <span class="number">2</span>)</span><br><span class="line">        y = <span class="number">168</span> + <span class="number">24</span> * (total / <span class="number">2</span>)</span><br><span class="line">        name = <span class="variable">$data_armors</span>[item[<span class="number">0</span>]].name</span><br><span class="line">        icon = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.icon(<span class="variable">$data_armors</span>[item[<span class="number">0</span>]].icon_name)</span><br><span class="line">        number = item[<span class="number">1</span>]</span><br><span class="line">        <span class="variable language_">self</span>.contents.blt(x, y, icon, <span class="title class_">Rect</span>.new(<span class="number">0</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">24</span>))</span><br><span class="line">        <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">28</span>, y, <span class="number">126</span>, <span class="number">24</span>, name)</span><br><span class="line">        <span class="variable language_">self</span>.contents.draw_text(x + <span class="number">28</span> + <span class="number">126</span>, y, <span class="number">30</span>, <span class="number">24</span>, number.to_s, <span class="number">2</span>)</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">@journal</span>.reward_gold &gt; <span class="number">0</span></span><br><span class="line">        str = <span class="string">&quot;获得金钱：&quot;</span> + <span class="variable">@journal</span>.reward_gold.to_s</span><br><span class="line">        y = <span class="number">168</span> + ((total-<span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">24</span></span><br><span class="line">        <span class="variable language_">self</span>.contents.draw_text(<span class="number">0</span>, y, width - <span class="number">32</span>, <span class="number">24</span>, str)</span><br><span class="line">      <span class="keyword">elsif</span> total == <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.contents.draw_text(<span class="number">0</span>, <span class="number">168</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="string">&quot;无&quot;</span>)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p> 注意那个journal方法的定义，只有在@journal和参数不相等的时候，才进行刷新，这样也是为了减少refresh调用的次数。</p><p>中间refresh定义得比较啰嗦，不过物品武器装备这三个在一起真的好烦啊，希望高手能精简一下哈。大家可能注意到了，我们现在创建的两个窗口的y坐标都是64而不是0，这是由于我们在最顶端要说明每个窗口是干什么用的。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>6.1.3  任务场景的制作<br>       有了这两个窗口，任务场景的制作就会相当简单。新加的东西不多，不过要注意这里在场景中生成Window_Base的方法，因为这个窗口内容太单一了，我们就不单独给设一个类了。<br>       另外，在update中，要保持左右窗口描述的任务一致，因此我们要不定期执行这个语句：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@contents_window</span>.journal = <span class="variable">@journal_window</span>.journal</span><br></pre></td></tr></table></figure><p>在这里，我们假设在地图Scene_Map上可以查看任务，那么在Scene_Map脚本也要进行输入的处理，这里略去过程了，想必大家已经会怎么弄了吧。<br>RU</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看任务的场景</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scene</span>_Journal</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">main</span></span><br><span class="line">    <span class="variable">@journal_window</span> = <span class="title class_">Window</span>_Journal.new</span><br><span class="line">    <span class="variable">@contents_window</span> = <span class="title class_">Window</span>_Journal_Contents.new</span><br><span class="line">    <span class="variable">@base1</span> = <span class="title class_">Window</span>_Base.new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">240</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="variable">@base1</span>.contents = <span class="title class_">Bitmap</span>.new(<span class="number">208</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="variable">@base1</span>.contents.draw_text(<span class="number">0</span>, <span class="number">0</span>, <span class="number">96</span>, <span class="number">32</span>, <span class="string">&quot;任务名称&quot;</span>)</span><br><span class="line">    <span class="variable">@base2</span> = <span class="title class_">Window</span>_Base.new(<span class="number">240</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="variable">@base2</span>.contents = <span class="title class_">Bitmap</span>.new(<span class="number">368</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="variable">@base2</span>.contents.draw_text(<span class="number">0</span>, <span class="number">0</span>, <span class="number">96</span>, <span class="number">32</span>, <span class="string">&quot;具体内容&quot;</span>)</span><br><span class="line">    <span class="title class_">Graphics</span>.transition</span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      <span class="title class_">Graphics</span>.update</span><br><span class="line">      <span class="title class_">Input</span>.update</span><br><span class="line">      update</span><br><span class="line">      <span class="keyword">if</span> <span class="variable">$scene</span> != <span class="variable language_">self</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="title class_">Graphics</span>.freeze</span><br><span class="line">    <span class="variable">@base1</span>.dispose</span><br><span class="line">    <span class="variable">@base2</span>.dispose</span><br><span class="line">    <span class="variable">@journal_window</span>.dispose</span><br><span class="line">    <span class="variable">@contents_window</span>.dispose</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">update</span></span><br><span class="line">    <span class="variable">@base1</span>.update</span><br><span class="line">    <span class="variable">@base2</span>.update</span><br><span class="line">    <span class="variable">@journal_window</span>.update</span><br><span class="line">    <span class="variable">@contents_window</span>.journal = <span class="variable">@journal_window</span>.journal</span><br><span class="line">    <span class="comment"># 按下 B 键的情况下，返回地图</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title class_">Input</span>.trigger?(<span class="title class_">Input</span><span class="symbol">:</span><span class="symbol">:B</span>)</span><br><span class="line">      <span class="variable">$game_system</span>.se_play(<span class="variable">$data_system</span>.cancel_se)</span><br><span class="line">      <span class="variable">$scene</span> = <span class="title class_">Scene</span>_Map.new</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>来看看这个脚本的效果吧，这个朴素的任务脚本就做完了，是不是很简单？<br><img src="/posts/d12553e4/6-1.png"></p><h2 id="6-2-默认回合制战斗场景的解读"><a href="#6-2-默认回合制战斗场景的解读" class="headerlink" title="6.2  默认回合制战斗场景的解读"></a>6.2  默认回合制战斗场景的解读</h2><p>RMXP中最复杂的场景脚本应当是这个回合制战斗了。虽然作为一个游戏的默认系统，但是如果接触RGSS时间不长，恐怕也难以写出一个没有BUG的回合制脚本。需要指出的是，游戏默认Scene_Battle虽然很长，但是从算法上和原理上都不难理解，从这个角度上来说也非常适合新手学习。</p><h3 id="6-2-1-准备工作"><a href="#6-2-1-准备工作" class="headerlink" title="6.2.1  准备工作"></a>6.2.1  准备工作</h3><p>我们打开Scene_Battle，翻开它的分割定义1，可以看到main方法以及update方法。有了解读脚本的基础，我们对main方法的基本定义模式已经非常熟悉了。这里main方法的结构和普通场景相似，初始化数据——生成窗口——主循环——释放。但是在这里，我们要额外生成战斗场景用的活动块，这里需要调用Spriteset_Battle类的一个对象，这里Spriteset_Battle是一个特殊的类，这个活动块里面含有几乎所有战斗画面上显示的内容（窗口除外），例如角色的战斗图形，战斗背景图等等。另外，战斗场景中需要显示技能和物品的窗口，但是在main方法里面没有生成它们。这样做的原因可能是为了节省内存空间，但是一遍一遍生成可能会以时间为代价。</p><p>接下来的update才是这里的关键所在。在update之前，先定义了几个Scene_Battle的内部方法，我们暂时可以先不看。update进行的方法，首先是刷新战斗事件，然后刷新系统对象，再然后是计时器，窗口，活动块。刷新完毕后，本应该等待玩家输入以便进行条件刷新，但是在这之前要等待一些效果执行完毕（包括手动等待），才能接受玩家的输入，这个机制和我们之前讲的输入等待是一样的。之后，就是各种条件刷新了。</p><p>在条件刷新下，我们看到，这里并不是根据窗口的激活情况进行的判断刷新，而是根据战斗进行的回合种类进行分拆。说是各种回合，其实就是在一个回合下的不同阶段而已。在后面我们会看到，在同一个阶段进行的刷新，才进一步根据窗口激活情况不同而进行选择刷新。所以，大家也要多多借鉴这种刷新机制，如果场景比较简单，就可以通过窗口激活状况进行刷新；如果场景比较复杂，那么你可能也要引入一个类似于“回合”的变量来控制。</p><h3 id="6-2-2-五个战斗阶段的解读"><a href="#6-2-2-五个战斗阶段的解读" class="headerlink" title="6.2.2  五个战斗阶段的解读"></a>6.2.2  五个战斗阶段的解读</h3><p>接下来我们就要分别说说这五个阶段Scene_Battle都做了些什么。</p><p>打开Scene_Battle分割定义2，在这个分割定义中，分别定义了第一阶段，第二阶段，第五阶段。这些阶段的执行都比较简单，为了方便放在一起了。</p><ul><li>第一阶段：自由战斗回合<br>这里说得很不清楚，自由战斗回合实际上就是指事先处理各种战斗事件，强制行动，玩家不能操控的回合。在战斗事件的设置中，如果选择了“回合0”，那么这样的事件会立即在进入场景后执行。其余的“回合X”，就是在经过了X回合之后的自由战斗回合（第一阶段）立即执行。如果执行完毕，那么就进入第二阶段。第一阶段就是这样短暂。</li><li>第二阶段：同伴命令回合<br>实际上就是进行队伍总体操作的回合，这场战斗你是打还是不打，如果选择“战斗”则进入第三阶段，如果选择“逃跑”，则进行相应的处理。在这里我们看到了逃跑的基本处理，代码如下：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_phase2_escape</span></span><br><span class="line">    <span class="comment"># 计算敌人速度的平均值</span></span><br><span class="line">    enemies_agi = <span class="number">0</span></span><br><span class="line">    enemies_number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> enemy <span class="keyword">in</span> <span class="variable">$game_troop</span>.enemies</span><br><span class="line">      <span class="keyword">if</span> enemy.exist?</span><br><span class="line">        enemies_agi += enemy.agi</span><br><span class="line">        enemies_number += <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> enemies_number &gt; <span class="number">0</span></span><br><span class="line">      enemies_agi /= enemies_number</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 计算角色速度的平均值</span></span><br><span class="line">    actors_agi = <span class="number">0</span></span><br><span class="line">    actors_number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> actor <span class="keyword">in</span> <span class="variable">$game_party</span>.actors</span><br><span class="line">      <span class="keyword">if</span> actor.exist?</span><br><span class="line">        actors_agi += actor.agi</span><br><span class="line">        actors_number += <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> actors_number &gt; <span class="number">0</span></span><br><span class="line">      actors_agi /= actors_number</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 逃跑成功判定</span></span><br><span class="line">    success = rand(<span class="number">100</span>) &lt; <span class="number">50</span> * actors_agi / enemies_agi</span><br><span class="line">    <span class="comment"># 成功逃跑的情况下</span></span><br><span class="line">    <span class="keyword">if</span> success</span><br><span class="line">      <span class="comment"># 演奏逃跑 SE</span></span><br><span class="line">      <span class="variable">$game_system</span>.se_play(<span class="variable">$data_system</span>.escape_se)</span><br><span class="line">      <span class="comment"># 还原为战斗开始前的 BGM</span></span><br><span class="line">      <span class="variable">$game_system</span>.bgm_play(<span class="variable">$game_temp</span>.map_bgm)</span><br><span class="line">      <span class="comment"># 战斗结束</span></span><br><span class="line">      battle_end(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 逃跑失败的情况下</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># 清除全体同伴的行动</span></span><br><span class="line">      <span class="variable">$game_party</span>.clear_actions</span><br><span class="line">      <span class="comment"># 开始主回合</span></span><br><span class="line">      start_phase4</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>逃跑成功与否取决于处于战斗中的敌人和角色速度平均值的大小（已经阵亡的战斗者和没有出现的战斗者不算在内），如果敌人和角色速度平均值相等，则由50%的几率成功逃跑。当然，如果逃跑失败了，游戏还是要继续的，这时候所有角色都没有行动，整个队伍只能被敌人痛扁一顿……当然，如果你不喜欢这种逃跑的设定，完全可以通过修改，跳过第二阶段，不妨自己试一下吧。</p><ul><li>第三阶段：角色命令回合<br>这个阶段相对前两个阶段，比较复杂，但是思路还是很明确的。在这个阶段，玩家为各个角色设定行动（当然行动能否执行取决于主回合执行的情况）。按照角色在队伍中的顺序来为各个角色设定他们的行为，首先是角色的基本命令，然后根据基本命令来选择接下来要显示的窗口。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_phase3</span></span><br><span class="line">    <span class="comment"># 敌人光标有效的情况下</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@enemy_arrow</span> != <span class="literal">nil</span></span><br><span class="line">      update_phase3_enemy_select</span><br><span class="line">    <span class="comment"># 角色光标有效的情况下</span></span><br><span class="line">    <span class="keyword">elsif</span> <span class="variable">@actor_arrow</span> != <span class="literal">nil</span></span><br><span class="line">      update_phase3_actor_select</span><br><span class="line">    <span class="comment"># 特技窗口有效的情况下</span></span><br><span class="line">    <span class="keyword">elsif</span> <span class="variable">@skill_window</span> != <span class="literal">nil</span></span><br><span class="line">      update_phase3_skill_select</span><br><span class="line">    <span class="comment"># 物品窗口有效的情况下</span></span><br><span class="line">    <span class="keyword">elsif</span> <span class="variable">@item_window</span> != <span class="literal">nil</span></span><br><span class="line">      update_phase3_item_select</span><br><span class="line">    <span class="comment"># 角色指令窗口有效的情况下</span></span><br><span class="line">    <span class="keyword">elsif</span> <span class="variable">@actor_command_window</span>.active</span><br><span class="line">      update_phase3_basic_command</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这就是第三阶段，根据窗口激活的不同来选择刷新方法。在这里，我们看到了特技窗口和道具窗口在这个地方生成。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_skill_select</span></span><br><span class="line">    <span class="comment"># 生成特技窗口</span></span><br><span class="line">    <span class="variable">@skill_window</span> = <span class="title class_">Window</span>_Skill.new(<span class="variable">@active_battler</span>)</span><br><span class="line">    <span class="comment"># 关联帮助窗口</span></span><br><span class="line">    <span class="variable">@skill_window</span>.help_window = <span class="variable">@help_window</span></span><br><span class="line">    <span class="comment"># 无效化角色指令窗口</span></span><br><span class="line">    <span class="variable">@actor_command_window</span>.active = <span class="literal">false</span></span><br><span class="line">    <span class="variable">@actor_command_window</span>.visible = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面的方法是开始选择特技，在最后的结束特技选择时，@skill_window会被释放掉。</p><ul><li>第四阶段：主回合<br>实际上就是战斗真正进行的阶段，前面几个阶段都是准备工作。<br>在这个阶段，系统会自动生成敌人的作战行动（见方法start_phase4中的语句），而后决定行动的先后次序，代码如下。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_action_orders</span></span><br><span class="line">    <span class="comment"># 初始化序列 <span class="doctag">@action</span>_battlers</span></span><br><span class="line">    <span class="variable">@action_battlers</span> = []</span><br><span class="line">    <span class="comment"># 添加敌人到 <span class="doctag">@action</span>_battlers 序列</span></span><br><span class="line">    <span class="keyword">for</span> enemy <span class="keyword">in</span> <span class="variable">$game_troop</span>.enemies</span><br><span class="line">      <span class="variable">@action_battlers</span>.push(enemy)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 添加角色到 <span class="doctag">@action</span>_battlers 序列</span></span><br><span class="line">    <span class="keyword">for</span> actor <span class="keyword">in</span> <span class="variable">$game_party</span>.actors</span><br><span class="line">      <span class="variable">@action_battlers</span>.push(actor)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 确定全体的行动速度</span></span><br><span class="line">    <span class="keyword">for</span> battler <span class="keyword">in</span> <span class="variable">@action_battlers</span></span><br><span class="line">      battler.make_action_speed</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 按照行动速度从大到小排列</span></span><br><span class="line">    <span class="variable">@action_battlers</span>.sort! &#123;|<span class="params">a,b</span>|</span><br><span class="line">      b.current_action.speed - a.current_action.speed &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>首先是把所有的敌人和角色都放到@action_battlers这个数组中。然后为所有即将行动的战斗者确定行动速度，具体方法参见Game_Battler分割定义1里面的make_action_speed，行动速度为当前战斗者的速度加上一个随机平移量，范围是0到10+战斗者的速度&#x2F;4。而后将目标数组按照速度大小，由小到大排序。</p><p>而后我们看到了update_phase4的原型，同样地，这个刷新操作也是根据步骤来进行，第四阶段共分为6个步骤。为什么要这样分呢？原因是第四阶段不需要进行玩家的任何输入（当然公共事件的除外），而现实战斗者行动效果的时候，要一个个地显示，即不会出现两个战斗者同时进行物理攻击或者释放特技的情况（如果需要改，可以自定义），因此这6个步骤是针对每一个战斗者而设计的。系统从刚刚生成的@action_battlers中，按照速度从大到小，依次选出一个战斗者（实际上就是@action_battlers[0]）作为当前行动的战斗者@active_battler，然后再进行各种操作。如此循环，当@action_battlers数组里面的元素都取出时，表示所有战斗者行动已经处理完毕，那么要开始一个新的回合。</p><ul><li><ul><li>【步骤1】准备行动<br>由于每一次行动都会影响到此次战斗胜败的判定（特指玩家胜败的判定），所以要在这一步进行一个判断，如果战斗胜败能够确定（即主角队伍和敌人队伍之一全灭），那么直接结束主回合，进入战斗的第五个阶段（在主角队伍胜利的情况下），否则才能进行下面的内容。具体判断方法参见Scene_Battle分割定义1的judge方法，战斗结束方法参见battle_end(result)方法。如果战斗需要继续进行，那么刷新战斗事件（注意不是物品或者技能的公共事件），从@action_battlers取出行动速度最大的作为@active_battler，进行各种准备操作（例如连续伤害和状态变化），然后就可以进行步骤2了。</li></ul></li><li><ul><li>【步骤2】开始行动<br>在这一步骤中，主要进行的是各种行动效果的判断，具体看代码：</li></ul></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_phase4_step2</span></span><br><span class="line">    <span class="comment"># 如果不是强制行动</span></span><br><span class="line">    <span class="keyword">unless</span> <span class="variable">@active_battler</span>.current_action.forcing</span><br><span class="line">      <span class="comment"># 限制为 [敌人为普通攻击] 或 [我方为普通攻击] 的情况下</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">@active_battler</span>.restriction == <span class="number">2</span> <span class="keyword">or</span> <span class="variable">@active_battler</span>.restriction == <span class="number">3</span></span><br><span class="line">        <span class="comment"># 设置行动为攻击</span></span><br><span class="line">        <span class="variable">@active_battler</span>.current_action.kind = <span class="number">0</span></span><br><span class="line">        <span class="variable">@active_battler</span>.current_action.basic = <span class="number">0</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="comment"># 限制为 [不能行动] 的情况下</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">@active_battler</span>.restriction == <span class="number">4</span></span><br><span class="line">        <span class="comment"># 清除行动强制对像的战斗者</span></span><br><span class="line">        <span class="variable">$game_temp</span>.forcing_battler = <span class="literal">nil</span></span><br><span class="line">        <span class="comment"># 移至步骤 1</span></span><br><span class="line">        <span class="variable">@phase4_step</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 清除对像战斗者</span></span><br><span class="line">    <span class="variable">@target_battlers</span> = []</span><br><span class="line">    <span class="comment"># 行动种类分支</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">@active_battler</span>.current_action.kind</span><br><span class="line">    <span class="keyword">when</span> <span class="number">0</span>  <span class="comment"># 基本</span></span><br><span class="line">      make_basic_action_result</span><br><span class="line">    <span class="keyword">when</span> <span class="number">1</span>  <span class="comment"># 特技</span></span><br><span class="line">      make_skill_action_result</span><br><span class="line">    <span class="keyword">when</span> <span class="number">2</span>  <span class="comment"># 物品</span></span><br><span class="line">      make_item_action_result</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 移至步骤 3</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@phase4_step</span> == <span class="number">2</span></span><br><span class="line">      <span class="variable">@phase4_step</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的代码结构非常简单，首先是要判断当前战斗者能不能进行行动，如果能进行行动，那么能进行什么样的行动。这里的restriction就表示行动的限制，4为完全不能行动，2和3分别表示普通攻击同伴和普通攻击敌人。而后便真正进行行动效果的计算。</p><p>在这里略去对行动效果计算的方法的解读，不过强烈建议大家看看这3个方法：attack_effect，skill_effect，item_effect，这三个方法可以在Game_Battler3里面寻找。这里面说的都是各种行动的效果是如何定义的，我们在改动战斗系统时，改动最频繁的就是这三个方法了。</p><ul><li><ul><li>【步骤3、步骤4、步骤5】显示动画<br>步骤3显示的是行动方的动画，步骤4显示的是对象方的动画，步骤5显示的是各种伤害（包括行动放和对象方），没什么好讲的，主要功能的实现是利用了@spriteset（战斗活动块）的方法，这个实例在一开始就已经生成了。大家如果有兴趣，可以翻开F1，搜索RPG::Sprite，在这里有战斗活动块的所有方法和属性的定义。</li></ul></li><li><ul><li>【步骤6】公共事件<br>在执行完动画之后，才轮到公共事件的处理。因此公共事件是每一个行动者行动的最后一步。执行完这一步后，返回到步骤1，进行下一个战斗者（如果有的话）的行动。</li></ul></li><li><p>第五阶段：结束战斗回合<br>这个阶段只有在角色队伍胜利的情况下才进行。主要功能是显示战后所得，获得战斗胜利的奖励。这里的方法非常简单，大家可以自行解读start_phase5，update_phase5执行的实际上是战斗结果窗口的显示，需要等待100帧才能显示战斗结果窗口，在主角按下C键的时候，结束战斗，返回地图画面。</p></li></ul><p>这样，整个默认的战斗系统就被我们解读完了，不知道效果如何。总觉得自己跟什么都没说似的呢……不过具体效果还要看大家体会了，我没有提及的代码，大家最好也看看，这样能为自己改脚本提供思路。</p><p>这个脚本教程贴已经快要接近尾声了哈，感觉自己已经把能说明白的东西都说了。下一章节，可能是最后一个章节了，我们将会谈谈Ruby内部的一些机制，这也是我使用Ruby多年的体会，大家就敬请期待吧。</p><h1 id="第7章节：尾声"><a href="#第7章节：尾声" class="headerlink" title="第7章节：尾声"></a>第7章节：尾声</h1><p>呼~写了这么久，这个脚本教程贴总算要杀青了。不过打开脚本编辑器，我们还有一些部分没有说到，比如说Interpreter类的脚本，我们就没深入讨论。不过，这对于一般的需要来说，已经足够了。那么在最后一章，我们要说一些零碎的内容。说是零碎，其实是编程的死角，这也是一个脚本党的必备知识。</p><h2 id="7-1-个人的几个体会"><a href="#7-1-个人的几个体会" class="headerlink" title="7.1  个人的几个体会"></a>7.1  个人的几个体会</h2><h3 id="7-1-1-关于alias"><a href="#7-1-1-关于alias" class="headerlink" title="7.1.1 关于alias"></a>7.1.1 关于alias</h3><p>这个词我们在很久之前就已经提到了，但是一直没有说它的用法，现在就补上吧。alias的意思是“别名”，在这里是给函数取别名。具体的使用方法是：alias 新方法名 旧方法名，新方法名和旧方法名用空格隔开。那么这个功能有什么用呢？主要是利用在方法的重定义上。当我们要重新定义一个方法，又不想覆盖原来的方法，那么alias就派上用场了。请看下面的例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:name</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">name</span>)</span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">    print <span class="string">&quot;我是&quot;</span> + <span class="variable">@name</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">alias</span> old_hello hello</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">    print “<span class="title class_">Hello</span>, I am ” + <span class="variable">@name</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 测试一下</span></span><br><span class="line">ryan = <span class="title class_">Person</span>.new(<span class="string">&quot;Ryan&quot;</span>)</span><br><span class="line">ryan.hello</span><br><span class="line">ryan.old_hello</span><br></pre></td></tr></table></figure><p>如果按照上述定义，第一个语句会在屏幕上显示“Hello, I am Ryan”，第二个语句会在屏幕上显示“我是Ryan”，可见alias具有保留原有方法的功能。</p><p>在这里，我们看到alias的威力还不算很大。这个语句一般用作整合脚本上，特别是给不会脚本的人写脚本时，我们要写出一个完整的脚本，让用户贴在Main前面即可，但是有时候并不是这样，假设我们要修改前面默认脚本的内容，如果不用alias，那么只能进行重定义。但是对于一些方法，我们可以这样：</p><p>假如你给Game_Temp增加一个名叫test_value的属性，并在initialize中将它初始化，我们可以用三种方法。一是直接在Game_Temp上进行修改，不过，如果写脚本给伸手党，那就不太好，二是把整个Game_Temp需要重定义的地方定义一遍，对于Game_Temp这样的脚本来说，重定义一遍无异于整体复制，脚本显得很不整洁，三就是利用alias，具体实现过程如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>_Temp</span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:test_value</span></span><br><span class="line">  <span class="keyword">alias</span> old_initialize initialize</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable">@test_value</span> = <span class="number">0</span></span><br><span class="line">    old_initialize</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这里，我们是先对initialize进行别名，然后重定义，在定义过程中，调用了原方法。因为这里的initialize做的工作就是赋值初始化，因此这样写是没有问题的。</p><p>不过，需要注意的是，不能给同一个方法起两个相同的别名，这样说似乎比较别扭，我们来看下面的例子：</p><p>假如上面的代码已经定义好，那么我现在继续往Game_Temp里面增加一个叫test_bool的属性（Game_Temp中已经有了我们刚刚增加的test_value，利用的也是alias），由于我们现在的initialize的功能已经能够初始化test_value，因此我们利用alias时，进行重定义的肯定是initialize方法而非old_initialize方法，但是我们不能写下面的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>_Temp</span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:test_bool</span></span><br><span class="line">  <span class="keyword">alias</span> old_initialize initialize</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable">@test_bool</span> = <span class="literal">false</span></span><br><span class="line">    old_initialize</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这样写的话，脚本肯定会出错，因为你又将initialize别名为old_initialize，而刚才那个名字已经有了对应的方法，这样就会出现一个符号表示两个方法的情况，引发内部冲突。因此这个时候就不能用old_initialize做别名了，应该换成别的。</p><h3 id="7-1-2-关于类变量-xxxx"><a href="#7-1-2-关于类变量-xxxx" class="headerlink" title="7.1.2 关于类变量@@xxxx"></a>7.1.2 关于类变量@@xxxx</h3><p>类变量我们在讲类的时候顺便也提了一句，这种变量我们一般不会用到，不过好歹也说一下吧。类变量和通常我们讲的类当中的实例变量不同，类变量作用于整个类的上面。作为一个类生成的实例，这个实例本身可以访问该类的类变量。这样说有些模糊，我们看下面的例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A</span><br><span class="line">  <span class="comment"># 定义类变量 @<span class="doctag">@a</span></span></span><br><span class="line">  <span class="variable">@@a</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="comment"># 定义实例变量 <span class="doctag">@a</span></span></span><br><span class="line">    <span class="variable">@a</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">a</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">a=</span>(<span class="params">a</span>)</span><br><span class="line">    <span class="variable">@a</span> = a</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">ab</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">@@a</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">ab=</span>(<span class="params">ab</span>)</span><br><span class="line">    <span class="variable">@@a</span> = ab</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a1 = A.new</span><br><span class="line">a2 = A.new</span><br><span class="line">a1.a = <span class="number">2</span></span><br><span class="line">a2.a = <span class="number">3</span></span><br><span class="line">a1.ab = <span class="number">5</span></span><br><span class="line">print a1.a  <span class="comment"># =&gt; 2</span></span><br><span class="line">print a2.a  <span class="comment"># =&gt; 3</span></span><br><span class="line">print a1.ab  <span class="comment"># =&gt; 5</span></span><br><span class="line">print a2.ab  <span class="comment"># =&gt; 5</span></span><br></pre></td></tr></table></figure><p>在这里，@a表示我们通常用到的实例变量，@@a表示类变量，在这里我们看到，@a这个变量是每个实例私有的变量，而@@a这个变量是两个实例公用的变量。因此我们得到结论，只要是属于同一个类的同一个类变量，无论用这个类的哪个实例修改它，都会有同样的效果，无论用这个类的哪一个实例访问它，都会得到同样的值。</p><p>值得注意的是，类本身，也可以对类变量进行修改，不过要来借助类方法来完成。类方法和模块方法比较类似，定义和使用的模式基本相同。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A</span><br><span class="line">  <span class="comment"># 定义类变量 @<span class="doctag">@var</span></span></span><br><span class="line">  <span class="variable">@@var</span> = <span class="number">0</span></span><br><span class="line">  <span class="comment"># 定义类方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.var</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">@@var</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.var=(var)</span><br><span class="line">    <span class="variable">@@var</span> = var</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">A.var = <span class="number">5</span></span><br><span class="line">p A.var <span class="comment"># =&gt; 5</span></span><br></pre></td></tr></table></figure><h3 id="7-1-3-相同和相等•clone•变量和指针"><a href="#7-1-3-相同和相等•clone•变量和指针" class="headerlink" title="7.1.3  相同和相等•clone•变量和指针"></a>7.1.3  相同和相等•clone•变量和指针</h3><p>这个也是我们经常说的一个问题，Ruby是以C语言为基础语言编写的，实际上是对C做的一个优化。我们都知道C语言中有指针这个东西，而Ruby中我们却看不到它。不是说Ruby中没有指针，而是Ruby已经采取某种方式将指针优化掉了。我们在编写程序的同时，就在使用大量的指针，只是我们从未发觉而已。为什么又说起这个事情来呢，这是源于本人最近的一道作业题，我嫌用C太复杂，于是就用Ruby了，但是有一个地方怎么也通不过，一时想破脑袋也没想明白。不过后来好在经过F1指点，终于明白了问题所在，接下来我们就看一下。</p><p>我们在前面说了，赋值运算符“&#x3D;”的作用是将右边的值赋给左边，传递过去的就是对象的引用。所以，当你把一个数组或者一个类的实例赋给一个变量，那么实际传递过去的就是变量的引用，如果你把这个值又赋给另外一个变量，那么依然是传递引用，对一个变量进行的操作必定会影响另一个。因此，有时候我们需要生成一模一样的一个对象，又不想让它们有任何关系，就要用到clone方法，这是Object类（最大的类）的方法，任何类的实例都可以调用，因此，写b &#x3D; a.clone，就能把a和b区别开来，而且他们的内容也完全一样。我们知道利用比较运算符“&#x3D;&#x3D;”可以判断两个对象是否相等，而这个运算符只能判断两个对象的值是否相等，例如，有b &#x3D; a.clone，然后判断b &#x3D;&#x3D; a，这个结果通常是true，不过，a和b并不相同，在Object类里面也有一个判断是否相同的方法equal?，如果执行b.equal?(a)，我们得到的结果将会是false，因为equal?是判断二者是否相同的方法，在这里，a和b仅仅是内容相同，而它们实际上是两个“变量”（即内存的地址不同，这并不稀奇，就好比你和你的双生同胞不是同一个人一样）。</p><p>但是，即使是这样，也会遇到一些费解的问题。例如，有下面的定义：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A</span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:data</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable">@data</span> = []</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x1 = A.new</span><br><span class="line">x1.data[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">x2 = x1.clone</span><br><span class="line">x2.data[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">print x1.data[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>在这里，我们看到屏幕上显示的是1，这个最初看起来是非常奇怪的事情。我们明明对x1做了复制，按理说x1和x2的应该只是内容一样而已，为什么对x2的修改也影响到x1呢？这里我们注意的是，clone进行的只是浅层次的复制，它只能复制对象里面所有变量的内容，而不能复制变量引用的内容。我们知道，一个变量如果表示数组，那实际上就是指向数组的引用，在这里@data就是一个数组，表示的就是数组的引用，而clone做复制时，仅仅把这个引用的值复制了过去，因此它们表示的还是同一个东西。除非你将x2的data重新定向，否则在x2的data上面的改动还是会影响x1。</p><h3 id="7-1-4-sprintf表达式"><a href="#7-1-4-sprintf表达式" class="headerlink" title="7.1.4  sprintf表达式"></a>7.1.4  sprintf表达式</h3><p>说实话，学C语言的人在Ruby里面看到这个，应该感到无比亲切吧。这可以说是为数不多被保留下来的语句啊。sprintf这个名字蛮奇怪的，print是“打印、输出”的意思，那么后面的f，缩写的是format，表示“格式”，连在一起就表示“格式输出”，当然printf也是C的基本函数之一，前面的s，是表示输出的去向，s缩写的是string，表示这个函数将一定的内容输出到一个字符串内。在C语言中，sprintf的第一个参数是表示接受输入的字符串（字符数组指针），但是在Ruby里面，这个字符串直接作为sprintf的返回值。具体使用方法，如果学过C了，肯定都知道，如果不清楚就F1看看，其中“%”表示格式转换描述，例如写a &#x3D; sprintf(“%d %d”, x1, x2)，就是把x1和x2的值分别替换两个%d，然后做成字符串送到a中，我们注意%d是整数转换描述，如果x1表示的不是整数，那么就会出错的，因此，格式输出一定要严格控制，千万不能出现转换错误。</p><h2 id="7-2-写在最后"><a href="#7-2-写在最后" class="headerlink" title="7.2  写在最后"></a>7.2  写在最后</h2><p>这个RGSS1教程帖就这样结束了，不知道能坚持看到最后的你们，能不能有所收获呢？我不敢期望这个教程的效果有多么强大，但是，只要它能为大家写游戏做出一丝一毫的贡献，我就知足了。</p><p>每次写完一章，我都很期待大家的回帖，不过从第四章开始，这个帖子基本没有什么回帖的了，于是我就一直连帖下去，一直连帖，直到最后我发现大家似乎已经没有心情看下去了。我想这也是我个人方面的原因，第5章和第6章中间间隔将近一个月，或者说是我才疏学浅，但总之，我写这个东西的目的就是让大家能学会分拆脚本，根据默认脚本或者其他大神的作品的构造来提炼出自己的东西。</p><p>很多人看到脚本教程，给出的评价，大多都是“变量计算、类那里还行，到后面就什么也看不懂了”、“看完教程后就学会了一个p函数，别的都没学会”，我其实还满希望我的教程能摆脱这个评价，但是现在想想，或许这个教程帖也难逃此厄运。毕竟，如果没有经历系统的学习，没有理解计算机工作的原理，只是走马观花地看教程，恐怕也没什么效果。这样的教程写出来，结果往往都是，会脚本的人更厉害了，不会脚本的人依然没学到什么……总之，虽然截稿了，但是很郁闷。</p><p>6R站上已经有了很多RMXP的经典教程，而且侧重点各有不同。推荐大家在阅读教程帖子的时候，在多个教程之间比对，发现其中的不同，从而提出问题。毕竟所有的教程都会有疏漏和错误，写出一个完美的教程也实在是太过于困难。</p><p>最后，建议想要学习脚本的同学，一定要多看，多提问，多练习，少伸手。学习的初期可能做不出自己想要的东西，这没有关系，学习脚本切忌急功近利，心急往往很容易冲淡学习脚本的热情。起初建议大家模仿默认脚本来修改和练习，慢慢磨合，今后使用脚本才能更加得心应手。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;本想在一篇文章里全部</summary>
      
    
    
    
    <category term="游戏开发" scheme="http://azkoree.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="rmxp脚本教程" scheme="http://azkoree.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/rmxp%E8%84%9A%E6%9C%AC%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="rmxp" scheme="http://azkoree.github.io/tags/rmxp/"/>
    
    <category term="游戏开发" scheme="http://azkoree.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="学习" scheme="http://azkoree.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="转载文章" scheme="http://azkoree.github.io/tags/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>【转载】RGSS1脚本入门参考</title>
    <link href="http://azkoree.github.io/posts/2347af05/"/>
    <id>http://azkoree.github.io/posts/2347af05/</id>
    <published>2025-12-08T07:56:41.000Z</published>
    <updated>2025-12-21T14:46:14.672Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1 id="57自己想说的话"><a href="#57自己想说的话" class="headerlink" title="57自己想说的话"></a>57自己想说的话</h1><p>对于学习rgss1很有帮助，是先前的RMXP脚本教程的作者RyanBern所写。<br>我怕它随时成为lostmedia，所以我把它转载过来。侵删<br>原文完成于2014.7.5，以下开始为原文内容。<br>原帖链接：<a href="https://rpg.blue/forum.php?mod=viewthread&tid=335455&extra=&authorid=356383&page=1">https://rpg.blue/forum.php?mod=viewthread&amp;tid=335455&amp;extra=&amp;authorid=356383&amp;page=1</a></p><hr><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>一位论坛的朋友和我说，他看过很多RMXP脚本的教程，但是感觉没得到什么帮助，脚本也总写不好。我想这也是很多论坛朋友的共同问题吧，想自己弄个脚本，却无从下手；想看教程，却一头雾水（尤其是游戏里面的F1，感觉要有一定的基础才能理解最主要的部分）。这些天在论坛里面逛了逛，有不少尝试着自制脚本的朋友，但写出的脚本却总也通不过。我也看到了一些朋友写的代码，不得不说，代码中很多错误都是源于对教程的误解和对范例脚本（也就是游戏默认的脚本）的错误移植，游戏默认内置脚本其实是个很好的参考，但是如果不加分析胡乱利用一通，当然是不行的。于是我想到写下这个帖子，帮助那些渴望写出自己脚本的朋友们，成为一个真正的“脚本党”。我其实也算是个写脚本的业余爱好者，同时也在不断挖掘RGSS1更深层次的东西，本贴介绍的，仅仅是RGSS1的冰山一角，但却是我们编写脚本最常用的知识和基础。发出这个东西，不敢说能让大家都成为脚本高手，至少能让大家对RGSS1有个更清楚的认识。以下教程中，大家可能对Ruby和RGSS1有所混淆，Ruby是一门程序设计的语言；而RGSS1是基于Ruby编写的脚本系统，有很多特定的功能。</p><p>这里写的是我对写脚本的一些理解，希望各位高手能积极提出意见，有哪里写得不对的地方，还请大家帮忙批评指正。另外大家如果遇到什么相关的问题，可以随时在帖子中询问，只要我有时间，我会立即为大家解答的。（当然求脚本之类的提问我在这里就不处理了，请移步RMXP 提问区）</p><p>配套脚本教学视频：<a href="https://rpg.blue/thread-381015-1-2.html">https://rpg.blue/thread-381015-1-2.html</a></p><p>【第二版序】<br>半年前这个教程杀青了，半年后再翻出来，感觉不是很满意，有些地方都没有说清楚。而且后面脚本解读那里，根本就是在利用“抄脚本——写分析”的模式，让人很难有欲望看下去。因此第二版会有一些改动。这半年来又接触了不少编程的技术，对一些问题的看法也和从前大大不同了，因此都写在这里，大家好好探讨一番。这次的改动，注重细节的解说，再加上理论与实践结合的部分（虽然还没有做，大家不要来BS我），想必能比第一版更好吧。</p><p>很多人觉得计算机很聪明，实际上，它是十分天真的。我们现在所看到它实现的强大功能，其实就是通过有限次的计算来实现的。我们说计算机很傻，是因为我们告诉它什么，它就做什么，因此，我们必须要好好和它沟通，它才能更好地为我们服务。</p><hr><h1 id="第0章节：预备知识"><a href="#第0章节：预备知识" class="headerlink" title="第0章节：预备知识"></a>第0章节：预备知识</h1><h2 id="0-1-几个重要的概念"><a href="#0-1-几个重要的概念" class="headerlink" title="0.1  几个重要的概念"></a>0.1  几个重要的概念</h2><h3 id="0-1-1-数字计算-运算符-表达式"><a href="#0-1-1-数字计算-运算符-表达式" class="headerlink" title="0.1.1  数字计算&amp;运算符&amp;表达式"></a>0.1.1  数字计算&amp;运算符&amp;表达式</h3><p>这个我相信大家都明白，数字计算是计算机最基本的功能，游戏里面的F1已经说得很详细了，在这里我只想说一些大家容易忽略的。</p><p><strong>赋值运算符“&#x3D;”：</strong></p><p>虽然很不起眼，但是，我们要注意的是，一定要把它和数学上的等号’&#x3D;’区分开，在这里赋值运算符的作用是把它右边的值赋给左边，左边通常是一个变量（它的概念我们即将会讲到）。不能给常量或者伪变量再次赋值。例如不能写3&#x3D;2这样的式子。另外，赋值运算符的优先级是最低的一个，因此一般把所有表达式都计算完毕后再进行赋值。</p><p><strong>除法’&#x2F;‘，取余数’%’：</strong></p><p>这两个运算符的用处十分广泛。大家一定要弄清整数的除法。在绝大多数编程语言中，整数的除法不会发生除不尽的问题，得到的结果，其实是两个数的商值。例如7&#x2F;2应该得到3，我们可以把它理解成7 &#x3D; 2 * 3 + 1因此结果是3，而不是3.5。取余数也就是7%3&#x3D;1。我们要注意，余数的正负和除数的相同（或者0），绝对值比除数小，因此，(-7)&#x2F;3&#x3D;-3，(-7)%3&#x3D;2。这要提醒大家注意的是，不要随便交换乘除法的顺序，否则会造成一些不可预料的错误。</p><p>例如，1&#x2F;3<em>3和1</em>3&#x2F;3最后算出的结果是不一样的，如果到这里你没有发现它们之间的不同，请回顾一下除法的意义。</p><p>另外，如果想得到小数形式的商，就要用7.0 &#x2F; 2，这样得到的是浮点数类型的3.5。注意，在计算机中，所有的浮点数都是不准确的，也就是说会有浮点误差，这是计算机精度有限造成的，因此，不能比较两个浮点数是否相等，因为通常你得到的都是“伪值”（即二者不相等）。所以，大家一定要充分利用整数，除非无法避免，尽量不要使用浮点数。</p><p><strong>条件表达式’? ：’：</strong></p><p>具体的使用方法是：表达式1 ? 表达式2 : 表达式3<br>意思就是系统先算表达式1，如果表达式1成立，则计算表达式2，否则计算表达式3。并且整个条件表达式的值就是表达式2或表达式3的值（取决于表达式1是否成立）。</p><p>这个语句因为比if语句简单，所以用途十分广泛，大家一定要熟练掌握。</p><p>例如，max &#x3D; x &gt; y ? x : y，这里的意思就是先比较x和y的大小，如果x比y大，则再计算表达式2（也就是x），否则计算表达式3（也就是y），再把计算后的表达式赋值给变量max。</p><p> 注：条件表达式有短路原则，如果表达式1成立，那么计算表达式2，而不去考虑表达式3（此时如果计算表达式3甚至可能发生错误）。同理，如果表达式1不成立，那么计算机也不会考虑表达式2的值。</p><h3 id="0-1-2-变量"><a href="#0-1-2-变量" class="headerlink" title="0.1.2  变量"></a>0.1.2  变量</h3><p>其实在第一部分已经用到了变量的概念，不过我相信大家对变量或多或少都有个了解，因此就没有再次引入变量的概念。但是，近期在论坛发现有一位朋友在讨论区提出了自己对变量的新看法，我跑去看了看，觉得还是比较深刻的，因此我在这里还要把它拿出来。</p><p>首先，变量是什么？一种很粗浅的理解就是，变量就是随着程序进行而有能力发生改变的量。它改变与否当然是服从编程者的意愿。但是，这个理解在我看来，并不是很深刻，因为很多人会把类似于a，b，这样的东西叫做变量，甚至有些人根据变量名称的汉语意思，来默认这个变量的作用。其实不然，类似a，b，x，level等等，我们应该把它看作一个符号，看作我们和计算机沟通的语言，而不是变量本身，而变量本身，则是存储在计算机内存中的一块数据。而就像我看的那篇帖子中说的，变量名其实就是告诉你，在内存的某处，存储这一堆数据，而这些数据代表的值是什么。因此，x &#x3D; 3的意思就是，内存中存储着一段表示整数3的数据，而x，就是所谓的“标签”，我把它换成小猫小狗什么的完全可以。</p><p>学过C语言的朋友可能会发现，Ruby里面是没有指针的，这个机制其实为写程序的人提供了很大的方便。Ruby并不是真的没有指针，而是在使用的时候，指针和变量的区别变得模糊起来。下面我们来重点说说Ruby的变量机制。</p><p>Ruby中，任意的符号都可以看作一个变量，并且不加声明就可以直接引用，未经过初始化的全局变量和实变量的值为nil。这个nil到底是何方神圣？其实nil是个伪变量，表示的是“无”，属于Ruby的一种抽象数据实例。程序运行前，在内存的某处的一堆数据来表示nil，所有没有被初始化的全局变量和实变量，都代表它。从这个角度来讲，Ruby中的变量和指针似乎是等价的。但是有时候会发生很多费解的事情，我们来看看下面的两个例子。</p><p>(1)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = a</span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">print b <span class="comment">#print 是系统内部的输出函数</span></span><br></pre></td></tr></table></figure><p>(2)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">4</span> <span class="comment">#这是给数组第2号单元赋值为4</span></span><br><span class="line">print b</span><br></pre></td></tr></table></figure><p>在第一个例子里面，屏幕上将会打印2，在第二个例子里面，屏幕上会打印124。</p><p>细心的朋友会发现，在（1）中改变了a的值，但是b的值没变；但是在（2）中就不同了，对a进行的某种操作也会在b那里反映出来。但是，无论是哪种情况，在执行b&#x3D;a之后，a和b表示的是<strong>同一块数据</strong>（指向内存中的同一片区域，即地址），而<strong>不是相同数据的不同拷贝</strong>，或者说，b是a的一个别名，你要找这片内存区域，说a也行，说b也行。</p><p>那么，我们应该如何去理解“变量”？在这里我们应该把“变量”都理解成“引用”，它们代表的并不是该数据内容的本身，而是该数据所在的内存地址。把变量的重新赋值理解为指针的指向改变，而数据内容的本身是没有变化的。（这点对Integer之类的东西貌似也是对的，因此你不能说把某一片用于表示“1”的内存区域修改，使其表示“2”，你只能把变量指针的指向从“指向表示’1’的内存区域”改变成“指向表示’2’的内存区域”）</p><p>在后面定义函数的时候，也会发生类似的现象。写过程序的朋友知道，函数上面的参数（我们叫做形式参数，简称形参）和实际的变量（我们叫实际参数，简称实参）没有什么关系，对形参的改变丝毫不影响实参的变化。举个例子来说，假如有下面的程序：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">a,b</span>)</span><br><span class="line">  t = a</span><br><span class="line">  a = b</span><br><span class="line">  b = t</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>函数的作用是交换a和b两个变量的值，但是如果运行下面的程序：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">swap(a,b)</span><br><span class="line">p a,b</span><br></pre></td></tr></table></figure><p>我们会发现a和b的值并没有发生交换，原因就是计算机只是把实际参数的值拷贝给了形式参数，之后函数内部对形式参数进行的操作与实际参数无关。</p><p>但是，我们刚才说过，变量实际表示的就是地址，而我们知道，相同的地址必定指向相同的内存空间，对同一块内存空间进行操作，变量的值当然会发生改变。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>)</span><br><span class="line">  a[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">f(a)</span><br><span class="line">print a</span><br></pre></td></tr></table></figure><p>得到输出的结果应该是233，这就意味着函数真正地对a进行了操作。因此，我们得出结论，传递到方法中的参数（实际是地址）会被复制一份，不会对实际的参数发生改变，而可以按照这个地址参数对其他区域进行操作，总之，实际参数的地址是不会变的。总之，一句话，这里函数参数的传值方式为“值传递（Pass By Value）”，记住这点也就不难理解上面的现象了。</p><p>最后我们要说Ruby中最常见的三种变量，这三种变量起作用的时机不同，用法不同，因此要分情况进行使用。</p><p><strong>（1）全局变量</strong><br>在Ruby中，全局变量以$开头，例如$t，$game_party，等等。它们是在程序的任何地方都有效的变量，也就是说，如果变量名字相同，那么必定就是同一个全局变量。因此，只有我们要创建共享范围比较大（在程序的不同地方都要用）的变量时，才能用到它，否则一般不用全局变量。最常见的例子，就是跨类进行全局变量调用，如果你定义了一个类，使用的过程中需要调用别的类的内容，就要用全局变量来帮忙。例如在Window_Item类中就调用了Game_Party类的实例$game_party，试想，如果$game_party不是全局变量，在Window_Item中，计算机不认识Game_Party中的符号，那么当然会发生访问错误。这个地方，到了我说类（class）的时候，大家会有更加清楚的认识。</p><p><strong>（2）实变量</strong><br>       在Ruby中，实变量以@开头，通常是跟具体对象关联的。<br>例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable">@name</span> = <span class="string">&quot;XX&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">pr_name</span></span><br><span class="line">    print <span class="variable">@name</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">print @name</span><br></pre></td></tr></table></figure><p>在这里，@name进入到了函数pr_name的内部，对@name进行访问时，访问的应当是“这个对象的@name”。但是如果在这个类之外写print @name，那么你一定看到的是nil，因为这时@name已经不是Person中的@name。</p><p><strong>(3)局部变量</strong><br>在Ruby中，局部变量就是没有前缀的变量，比如level，x，等等。这一类的作用范围更窄，只是在定义函数内部有效，作为块参数的局部变量只在当前块内有效。在函数外面则是无效的。因此，我们在函数临时需要一个变量，函数结束后完全不需要的时候，就应该用这种变量。另外，函数的形式参数也要用局部变量表示。在这里面说明的一点就是，这种类型的变量是没有默认值的。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span></span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun2</span></span><br><span class="line">  b = a + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这里fun中的a和fun2中的a一毛钱关系都没有，它们是两个符号。所以我们明显看到，fun2中，对a进行的操作时非法的，因为此时a没有初始化，所以系统不能把它看做一个变量，在后面我们要说到，函数名字（方法）也是采用这种无前缀符号形式表示，系统会寻找与之同名的方法，如果还找不到方法，那么运行的时候，系统会提示错误信息No method error。</p><p>但是，自动变量的好处就是用完能及时回收，保证内存空间，但是对于全局变量，如果创建出来，在写程序的人没有下达命令的时候，系统是不敢轻易回收它的。试想如果程序里面的变量都是全局的，那么用不了多长时间，内存就塞满了，这对运行程序来说是非常致命的。因此大家务必要清楚什么时候该用什么变量，才能做一个合格的“准脚本党”。</p><h3 id="0-1-3-常量和伪变量"><a href="#0-1-3-常量和伪变量" class="headerlink" title="0.1.3  常量和伪变量"></a>0.1.3  常量和伪变量</h3><p>在这里顺便介绍一下常量和伪变量。</p><p>常量，顾名思义就是这个量代表一个特定的值，一般不能被改变。Ruby中常量的表示方法是用首字母大写的标识符表示，例如Icon，MAXNUM等等，因此常量必须要赋予初始值。当然，常量也有作用的范围，使用常量时，建议把它们放到命名空间中去，这样能够突出常量的作用域，避免发生混淆。常量的作用是为了编写程序的方便，例如，论坛上有很多这样的脚本，显示一个窗口，但是在40号开关打开的情况下，窗口是不显示的。我们可以在外面利用常量WINDOW &#x3D; 40来表示控制其是否显示的开关ID，这样如果要改动，只需要改动一处即可。</p><p>伪变量，是一类特殊的变量。Ruby中的伪变量常见的有4个，分别是self，true，false，nil。下面我们分别来说一下。</p><ul><li><p>self：被处理对象的本身，这个概念在我们讲到类的地方会详细说明，初学者会比较难懂（说实话我在接触Ruby初期就完全不懂得self的含义）</p></li><li><p>true&#x2F;false：表示一种逻辑值，实际是TrueClass&#x2F;FalseClass的唯一实例。true是恒真，false是恒假，一般作为if的条件判断来使用，之间的运算符合逻辑运算。</p></li><li><p>nil：Ruby中的特殊数据类型实例，表示“无”，注意，它并不能代替不同类所谓“空”的概念。在数组类型中，空数组用[]表示，不用nil，在字符串中，空字符串用””表示，也不用nil。nil本身没有多少方法，大家可以认为它也表示一个恒假的值。</p></li></ul><p>值得一说的是，表示伪的方式有很多，大家一定要记住2种，false，nil，这两个都表示伪，和C语言不同的是，数字0以及其他的值都表示真。[此处感谢无脑之人的宝贵意见]</p><h2 id="0-2-几个建议"><a href="#0-2-几个建议" class="headerlink" title="0.2  几个建议"></a>0.2  几个建议</h2><p>在本章节的最后，给大家提几个建议。</p><p><strong>0.2.1</strong> 写任何脚本都要有良好的书写规范，脚本中要注意缩进，要有层次感。变量和运算符之间，最好用空格隔开。例如x &#x3D; a + b这样。</p><p><strong>0.2.2</strong>  变量名字要取得适当，尽量取一些有含义的名字，这样能让写程序和看程序的人知道这个变量代表什么。例如表示等级，就用level，而不是用简单的m或者n。循环变量一般都用i，j表示，这点大家养成习惯就好。另外，短下划线“<em>”看做一个字母，如果要分隔变量之间的单词，请用</em>，例如icon_size，中间的“_”当然不能换成空格。大家使用标识符时，不要使用中文字符，以免发生错误。</p><p><strong>0.2.3</strong>  要培养自主纠错能力，不要提示个什么错误就茫然不知所措。系统弹出那个小小的对话框经常会包含重要的错误信息，这样能协助你改正错误。出现的错误，可能是Syntax Error（语法错误，可能是少打end或者是捏造了不存在的写法），可能是No Method Error（未定义方法错误，可能是对nil调用方法或者是类的概念模糊），可能是Name Error（命名错误），一切都要具体情况具体分析。</p><h2 id="0-3-有关变量-指针-地址的重要补充（第二版更新）"><a href="#0-3-有关变量-指针-地址的重要补充（第二版更新）" class="headerlink" title="0.3  有关变量&#x2F;指针&#x2F;地址的重要补充（第二版更新）"></a>0.3  有关变量&#x2F;指针&#x2F;地址的重要补充（第二版更新）</h2><p>这个是补充的内容，有兴趣的初学者可以看看，当然大神什么的就免了。</p><p>写这里的原因是时隔半年，突然发现自己的教程里面有很多东西没有说清楚。当然半年前还没有学过Java基础课，对有些东西的猜测也不敢随便写上去，现在把它补上。</p><p>在变量机制方面，Ruby和Java非常相似。不同的是，Ruby使用变量前无需声明，因此不必告诉编译器各种变量的类型，Java中使用变量之前还是要声明的。还有一点不同就是Ruby是“万物皆对象”，即所有的数据都是一个对象，而Java除了对象以外，还有类似于int，char等基本数据类型。我们下面说的就是对象这一方面。</p><p>如果想要创建一个对象的实体，就必须对类调用new方法，这样系统会在内存中动态地开辟一块区域，然后用调用构造方法initialize，最后把对象的引用返回给变量。如果不调用new方法，系统不会在内存中开辟区域。<br>下面是一个例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A</span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:x</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:y</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:z</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">x,y,z</span>)</span><br><span class="line">    <span class="variable">@x</span> = x</span><br><span class="line">    <span class="variable">@y</span> = y</span><br><span class="line">    <span class="variable">@z</span> = z</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>执行：a &#x3D; A.new(0,0,0)，效果如图</p><p><img src="/posts/2347af05/1.png"></p><p>执行：b &#x3D; A.new(1,1,1)，效果如图</p><p><img src="/posts/2347af05/2.png"></p><p>注意到变量a和b的地址不同<br>执行：b &#x3D; a，效果如图</p><p><img src="/posts/2347af05/3.png"></p><p>执行完毕后，a和b变成了一个地址，指向了同一片内存区域。这就相当于为同一片内存区域建立了两个标签，或者说起了个别名，无论对a还是对b访问都会访问到这个区域。也就是说，a.x &#x3D; 2和b.x &#x3D; 2的效果完全相同。</p><p>那么，原来b代表的内存空间去哪了？即上面图的最右的部分，它不被任何指针变量所拥有，也不可能通过其他变量访问到它。像这种不被任何指针变量所拥有的内存区域，就应当被回收，以供别的变量使用。Ruby和Java相同，都有一套GC机制（Garbage Collection），它会定期检查内存空间是否已经不被任何一个指针变量所引用，如果没有任何指针指向它，GC就会把它回收再利用。注意，GC执行不是实时的，否则的话效率会变得很低。</p><p>说这里有什么用呢？是为了解释RGSS1中一处不太好理解的脚本（至少个人认为是这样），要解释这个地方，还需要了解一下Ruby存储对象的机制。</p><p>我们先看下这个脚本：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>_Party</span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 同伴成员的还原</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">refresh</span></span><br><span class="line">    <span class="comment"># 游戏数据载入后角色对像直接从 $game_actors</span></span><br><span class="line">    <span class="comment"># 分离。</span></span><br><span class="line">    <span class="comment"># 回避由于载入造成的角色再设置的问题。</span></span><br><span class="line">    new_actors = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [email]<span class="number">0</span>...<span class="variable">@actors</span>.size[<span class="regexp">/email]</span></span><br><span class="line"><span class="regexp">      if $data_actors[@actors[i].id] != nil</span></span><br><span class="line"><span class="regexp">        new_actors.push($game_actors[@actors[i].id])</span></span><br><span class="line"><span class="regexp">      end</span></span><br><span class="line"><span class="regexp">    end</span></span><br><span class="line"><span class="regexp">    @actors = new_actors</span></span><br><span class="line"><span class="regexp">  end</span></span><br><span class="line"><span class="regexp">end</span></span><br></pre></td></tr></table></figure><p>这个方法出现在Game_Party中，我第一次看这里的时候，注释就没有看懂。什么叫“游戏数据载入后角色对象直接从$game_actors中分离，回避由于载入造成的角色再设置问题”？</p><p>而后全局搜索$game_party.refresh，发现它只出现在一个地方：Scene_Load(101)。可见真的是为了处理载入方面的问题。那么，既然载入了，为什么还要多次一举这样设置一番呢？</p><p>稍微懂点RGSS1的人都知道，$game_actors是存储所有主角角色的变量，编写的时候利用了类Array的外壳。而$game_party.actors是存储当前队伍中所有角色的数组，当然这个集合是所有角色集合的子集。那么，这两个地方都有指向Game_Actor类的引用，它们必须要保持一致。下面的图形能够说明这一问题。</p><p>但是，如果涉及到对象的存储问题，实际就不是这样了。我们在Scene_Save中可以看到，系统对$game_actors和$game_party都做了存储。因为写入文件的是对象，所以不但要把对象本身写入，而且要把对象内部的引用也要写入，如果对象内部的引用还有引用，那么也要写入……说白了，要写入$game_party本身，也要写入$game_party.actors这个数组对象，注意，写入$game_party本身只写入了$game_party.actors数组的引用，数组本身的内容没有写入。由于$game_party.actors是对象数组，因此还要把数组中的每一个Game_Actor对象都写入进去。而刚才我们提到，$game_actors中也含有所有Game_Actor对象，这样一来，同样的数据要写入两遍。读取的时候自然也要读两遍。我们在这里做个测试：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scene</span>_Load</span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 读取存档数据</span></span><br><span class="line">  <span class="comment">#     file : 读取用文件对像 (已经打开)</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">read_save_data</span>(<span class="params">file</span>)</span><br><span class="line">    <span class="comment"># 读取描绘存档文件用的角色数据</span></span><br><span class="line">    characters = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="comment"># 读取测量游戏时间用画面计数</span></span><br><span class="line">    <span class="title class_">Graphics</span>.frame_count = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="comment"># 读取各种游戏对像</span></span><br><span class="line">    <span class="variable">$game_system</span>        = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="variable">$game_switches</span>      = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="variable">$game_variables</span>     = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="variable">$game_self_switches</span> = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="variable">$game_screen</span>        = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="variable">$game_actors</span>        = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="variable">$game_party</span>         = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="variable">$game_troop</span>         = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="variable">$game_map</span>           = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="variable">$game_player</span>        = <span class="title class_">Marshal</span>.load(file)</span><br><span class="line">    <span class="comment"># 加上这个</span></span><br><span class="line">    p <span class="variable">$game_actors</span>[<span class="number">1</span>].to_s,<span class="variable">$game_party</span>.actors[<span class="number">0</span>].to_s</span><br><span class="line">    <span class="comment"># 魔法编号与保存时有差异的情况下</span></span><br><span class="line">    <span class="comment"># (加入编辑器的编辑过的数据)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$game_system</span>.magic_number != <span class="variable">$data_system</span>.magic_number</span><br><span class="line">      <span class="comment"># 重新装载地图</span></span><br><span class="line">      <span class="variable">$game_map</span>.setup(<span class="variable">$game_map</span>.map_id)</span><br><span class="line">      <span class="variable">$game_player</span>.center(<span class="variable">$game_player</span>.x, <span class="variable">$game_player</span>.y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 刷新同伴成员</span></span><br><span class="line">    <span class="variable">$game_party</span>.refresh</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在读取数据完毕之后，我们来看看这两个对象的地址。注：所有对象都有to_s方法，如果不加重设的话，返回的是引用的地址。</p><p>由于$game_actors实际有意义的数据是从下标[1]开始，因此$game_actors[1]和$game_party.actors[0]是一样的，但是它们的地址却不一样。这就要调用$game_party.refresh，让这两部分引用保持一致性。</p><p>大家可以想想，如果不调用$game_party.refresh，会出现什么后果，而此时的内存地址模型又是怎样的？</p><p>预备知识就说到这里吧，虽然比较繁琐，但是我觉得在帮助上还是看不到的。这个帖子是连载，有时间我会写后面的内容，那些才是重头戏，大家一起期待之后的帖子吧。</p><p>有了预备知识，我们就可以进入Ruby中运用最广泛的部分——类（class）了。我在这里要说的是，在介绍类之前，我认为大家应该对Ruby的语法有了大致了解，对一些基本的概念也都掌握了，例如控制语句，函数，所以就没有再重复这些东西。如果大家有不明白的，请关注下RMXP的F1，那里面已经说得很清楚了。</p><h1 id="第1章节：类"><a href="#第1章节：类" class="headerlink" title="第1章节：类"></a>第1章节：类</h1><h2 id="1-1-类-实变量-实例方法"><a href="#1-1-类-实变量-实例方法" class="headerlink" title="1.1  类&amp;实变量&amp;实例方法"></a>1.1  类&amp;实变量&amp;实例方法</h2><h3 id="1-1-1-类的概念"><a href="#1-1-1-类的概念" class="headerlink" title="1.1.1  类的概念"></a>1.1.1  类的概念</h3><p>类其实是一个比较难说的概念，Ruby是面向对象的编程语言，所谓对象，就是计算机中的抽象数据，而且数据之间有一定的逻辑和结构关系。所谓类，不严格地来讲，就是抽象数据类型。翻开RMXP的F1，我们会发现，所有的类，竟然也都是一个对象，这就是我们所说的“万物皆对象”的观点。打比方来说，人类可以看作是一个类，那么人类的每一个个体就可以看作是一个对象，不知道这样是不是能好理解些。从感性的角度上来说，类应当是对象的一个集合。所有的人就构成了一个人类，而人是人类的一个实例(Instance)。类的上面定义了“属性(Property)”和“方法(Method)”。属性我们可以理解为描述（类生成）对象的性质，比方说人的身高，体重等等；方法可以理解为对象的某种操作，比方说吃饭，喝水，说话等等。对于类本身，还有专属于类的类变量和类方法。另外，类之间有继承关系，有多态性(Polymorphism)。如果你能理解这些，那么理解类也就不难了。</p><h3 id="1-1-2-实变量-实例方法"><a href="#1-1-2-实变量-实例方法" class="headerlink" title="1.1.2  实变量&amp;实例方法"></a>1.1.2  实变量&amp;实例方法</h3><p>每一个类的对象（实例）都有属于自己的变量和方法，所谓实例的变量，就是定义在该对象中的，只限于该对象自己使用的变量，实例方法，也就是只有属于这个类的对象才能使用的方法。我们举了例子来具体说明：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="comment">#定义一个叫Person的类</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable">@name</span> = <span class="string">&quot;Ryan&quot;</span></span><br><span class="line">    <span class="variable">@gender</span> = <span class="string">&#x27;M&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">    print <span class="string">&quot;I am &quot;</span> + <span class="variable">@name</span> + <span class="string">&quot;!&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个名叫Person的类就定义好了。</p><p>首先说一下，Person是上面我们所说那个“类的类（Class）”中的一个实例，Class类中的实例只有一个方法叫做new，调用方法要用圆点运算符“.”表示。格式是a.method(…)，</p><p>其中a是该类的一个实例，method是方法的名字（函数名字，必要的时候要带参数）。</p><p>【关于initialize方法】每个类都能定义一个名叫initialize的方法，这个方法比较特殊，是类的构造方法，或者成为“构造器”。当你使用Xxx.new生成一个类的实例时，便自动调用了这个initialize方法，’.new’后面跟的参数会原封不动地传递到initialize中去。</p><p>刚才我们说过了，Person是Class中的一个实例，那么Person.new的意思就是生成一个Person类的实例。我们接下来插入下面一个代码：<br>R</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ryan = <span class="title class_">Person</span>.new</span><br><span class="line">ryan.hello</span><br></pre></td></tr></table></figure><p>这两句的意思是生成一个Person类的实例，储存在一个变量中，然后调用该类的方法。因此执行完这两句之后，屏幕上将会打印出I am Ryan!的字符串。</p><p>在上一章节我们已经说过，如果一个变量是对象的一部分数据，那么要把它定义成实变量的形式（即@开头的变量），这样定义出来的变量在整个类的内部都是有效的。试想如果把上面的语句中所有的@都去掉，那么后果将会是……</p><p><strong>给initialize方法添加参数</strong></p><p>我们回头再来看看这个程序片段。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="comment">#定义一个叫Person的类</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable">@name</span> = <span class="string">&quot;Ryan&quot;</span></span><br><span class="line">    <span class="variable">@gender</span> = <span class="string">&#x27;M&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">    print <span class="string">&quot;I am &quot;</span> + <span class="variable">@name</span> + <span class="string">&quot;!&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们会发现，这个类别建立好了之后，所有的实变量的值都是固定的，这就导致我们只能建立相同内容的实例，因此我们要稍稍改装一下，让建立的实例拥有不同的初值。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="comment">#定义一个叫Person的类</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">name,gender</span>)</span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">    <span class="variable">@gender</span> = gender</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">    print <span class="string">&quot;I am &quot;</span> + <span class="variable">@name</span> + <span class="string">&quot;!&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的initialize是所有类一般要定义的方法，在一些面向对象的语言中，把这个方法叫做“构造方法”或者“构造器”。实际上，Person.new这个语句已经在调用initialize，所有类的初始化函数名字必须是initialize，这也是Ruby的规定。这里的initialize带有2个参数，我们回忆一下函数参数的概念，就会发现@name和name根本不是一回事。这样定义好了之后，我们可以写下面的语句了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ryan = <span class="title class_">Person</span>.new(<span class="string">&quot;Ryan&quot;</span>,<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">ryan.hello</span><br></pre></td></tr></table></figure><p>这样和刚才的效果相同，但是我们可以随便设置实例的初值。</p><p><strong>实变量公开化</strong></p><p>虽然我们可以用上面定义的类生成一个个实例，但是我们想一下这种情况：有一天Ryan出门了，见到了一个漂亮的女孩，因为我们定义了hello方法，所以Ryan很轻松地向她打了个招呼。女孩于是问：”Ryan”这个名字怎么拼啊？Ryan这时却抓耳挠腮，因为Ryan还没学会怎么让对方知道自己的名字拼写。再比如，Ryan觉得这个名字太简单了，想改成”RyanBern”（依然很矬），但是依然没有办法改变自己的名字。解决上面两个问题，就要用我们的实变量公开化。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="comment">#定义一个叫Person的类</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">name,gender</span>)</span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">    <span class="variable">@gender</span> = gender</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">    print <span class="string">&quot;I am &quot;</span> + <span class="variable">@name</span> + <span class="string">&quot;!&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment">####</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">name</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">@name</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">name=</span>(<span class="params">name</span>)</span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment">####</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们加入了两个方法，第一个函数是返回实例中@name的值，第二个函数的作用恰恰是修改实例中@name的值。</p><p>我们注意到，这两个方法的名称比较奇特，和@name这个实变量很相似。实际上，第一个方法叫做’name’，第二个方法叫做’name&#x3D;’，并且带一个参数。你可能会问了，怎么会有名字这么奇怪的方法？这种方法在C++&#x2F;Java中都是没有的（除非你想操作符重载，但是即使重载了，效果也不如Ruby里面的这个好），而Ruby之所以这样做，是出于对实变量保护隐藏的目的。我们在类对象的外面，是没有办法修改对象内部的变量的，如果真的需要修改，那么只能通过定义方法的形式。注意，第二个函数开头的两个name是不一样的，前面那个是方法名字，括号里面的是形参名字。</p><p>有了这两个函数，我们可以写（假设Ryan已经定义好了）：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nam = ryan.name <span class="comment">#将ryan的<span class="doctag">@name</span>赋值给变量nam</span></span><br><span class="line">ryan.name += <span class="string">&quot;Bern&quot;</span> <span class="comment">#将ryan的<span class="doctag">@name</span>后面加个&quot;Bern&quot;</span></span><br></pre></td></tr></table></figure><p>这里注意，上面的例子中第二句同时调用了’name’方法和’name&#x3D;’方法，请仔细思考一下。</p><p>这种通过定义方法来公开变量，是Ruby中最常见的。实际上，定义这样的函数之后，可以把被定义的变量看作是类的一个属性，我们可以获取属性的值或者修改属性的值（但严格来讲，【属性】这个概念并不存在于Ruby当中）。一种简单的理解，就是把’name’，’name&#x3D;’，‘@name’联系在一起，’name’方法返回‘@name’的值，’name&#x3D;’方法修改‘@name’的值。将原点运算符’.’理解为“的”，那么a.name就可以理解为某人的名字。但是我们要知道，其实圆点运算符表示的就是类方法的调用，加上属性的概念是为了突出这种方法的特殊地位。这样，相关的实变量便可以通过外部访问。</p><p>当然，这样编写可能会浪费大量的篇幅，我们在这里有比较简单的形式来代替上面的两个方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">attr_accessor</span> <span class="symbol">:name</span></span><br><span class="line"><span class="built_in">attr_reader</span> <span class="symbol">:name</span></span><br><span class="line"><span class="built_in">attr_writer</span> <span class="symbol">:name</span></span><br></pre></td></tr></table></figure><p>其中，attr_accessor是后面两个的合并，同时具备两种功能。</p><p>而attr_reader只定义了’name’方法；attr_writer只定义了’name&#x3D;’方法，表示只允许读或者只允许写。</p><p>在这里我们注意一个问题，’attr_’开头的这一串文字，不是所谓关键字，也不是所谓变量声明。它们本身就是方法（隶属于Module），而它们的作用，就是生成其他的方法。而’:name’就是它们的参数（这是一个Symbol对象，也可用字符串对象代替）。它们生成的方法有最简单的形式，即’name’方法是单纯返回@name的值，’name&#x3D;’方法是单纯修改@name的值。如果你想要让这两个方法变得复杂，那么就不要使用’attr_xxxx’。</p><p>因此，我们打开脚本编辑器，映入眼帘的Game_Temp，里面就是这些东西，仔细看看也没什么了不起的是吧？</p><h3 id="1-1-3-父类-子类-类扩充-方法重写-Override"><a href="#1-1-3-父类-子类-类扩充-方法重写-Override" class="headerlink" title="1.1.3  父类&amp;子类&amp;类扩充&amp;方法重写(Override)"></a>1.1.3  父类&amp;子类&amp;类扩充&amp;方法重写(Override)</h3><p>在这里我们引出父类和子类的概念。假设我们定义好了一个类Person，现在我定义它的子类Student，那么我们要写：</p><p>class Student &lt; Person，表示Student是Person类的子类。那么Student这个类所有的实例的性质，都会具有Person类的所有性质。即如果student是Student的一个实例，那么在Person类中定义的实变量和方法，student都能继承下来。这有点类似于“遗传”的概念。因此我们可以写student.name，student.hello等等这样的语句。</p><p>引入这一概念的原因，也是为了编程的方便。在计算机所有的对象中，虽然很多对象都属于不同的类，但是他们也同时具有很多的共同性质。那么我们可以先把它们的共同性质定义出来，做成一个父类，然后再分别定义它们特有的性质。在RGSS中，最明显的就是Window类，窗口类的父类是Window，然后Window_Base是它的一个字类，表示一般的窗口；Window_Selectable则是Window_Base的一个字类，表示具有光标的滚动窗口类。这两个类会衍生出一系列的子类，总体说分两种，不带光标以及滚动功能的，基本都是Window_Base的子类，具有光标以及滚动功能的，基本都是Window_Selectable的子类。有人会说，既然Window_Selectable是Window_Base的子类，那么我们岂不是可以把下面所有窗口类都归到Window_Selectable下？这是不行的，Window_Selectable比Window_Base更丰富，但是需要的内存空间也就更多，如果你要一个不带滚动功能的类，却设置到了Window_Selectable下，那么很多内存空间都没有被利用上，这显然是我们不需要的。</p><p><strong>第二版新增</strong></p><p>值得一提的是，类之间的结构定义体现了一个人编程素养的高低。在制作程序时，如果要新增某种功能，一定要引入新的类。但是怎么去引入？是直接引入所需类，还是从父类做起，以便有更好的适应性？这都是问题。对于两个不同的类，是做成父类——子类比较好，还是做成两个平行毫不相关的类比较好？答案并非十分明确。在这里举一个Java中的例子，我觉得很有参考价值。在Java的AWT包中，有Menu（菜单类）和MenuItem（菜单项类，即菜单拉开中的各个选项）。如果让你制作，你会把它们的关系定义为：</p><p>（1）父类——子类？</p><p>（2）子类——父类？</p><p>（3）两个平行类？</p><p>在Java中，这两个类的关系是第二种，Menu（菜单类）是MenuItem（菜单项类）的子类？啥？搞错了吧？菜单项包含在菜单的里面，怎么反而菜单项是父类？这个问题稍加思考，便可以赞叹编写Java-AWT包人员的高明之处。我们点开一个菜单，里面有各种菜单项，当然也包括一些可展开的菜单（即二级菜单），从这个角度上来讲，菜单就是一种特殊的菜单项，只不过它可以展开而已。因此MenuItem是Menu的父类是没问题的。</p><p>提到了父类——子类，那么还有一个东西就不得不提，那就是抽象类(abstract class)</p><p>尽管在Ruby中，并没有看到类似于抽象类的字眼，但是我们还是能够深刻地体会这种编程思想。面向抽象的编程思想也是编写这样程序的重要思想之一。抽象类是高度概括的一个类，它包含着它所有子类的一般行为。正因为它的高度概括性，它就必须作为一个父类出现，等待着别的类去继承它，扩充它。而自己本身，由于内容过于概括，因此不适合实例化一个对象。你问我这种现象的例子有没有？很明显，Object类就是一个抽象类。它定义了对象的一般行为，Object类作为所有类的祖宗，有着无可替代的高度概括性。定义出一个好的抽象类能够让你的代码更加简洁，易懂，而且显得有水平。</p><p>我们再看一个例子，RGSS1中的Game_Battler，它就是一个抽象类。它的两个已知子类分别是Game_Actor和Game_Enemy。啥？为啥说它是抽象类？我们看看下面的代码。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>_Battler</span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 获取 MaxHP</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">maxhp</span></span><br><span class="line">    n = [[base_maxhp + <span class="variable">@maxhp_plus</span>, <span class="number">1</span>].max, <span class="number">999999</span>].min</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">@states</span></span><br><span class="line">      n *= <span class="variable">$data_states</span>[i].maxhp_rate / <span class="number">100.0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    n = [[<span class="title class_">Integer</span>(n), <span class="number">1</span>].max, <span class="number">999999</span>].min</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这是定义MaxHp的一段代码，比较简洁。我们注意def下面那句n &#x3D; base_maxhp + @maxhp_plus ….</p><p>问，base_maxhp为何物？</p><p>它并不是局部变量，那就是一个方法了。</p><p>在Game_Battler搜索def base_maxhp，结果啥也没找到。</p><p>也就是说，Game_Battler里面的maxhp引用了一个没有在类内部定义的一个方法？这怎么可以？</p><p>这怎么不可以？？</p><p>我们再次搜索def base_maxhp，结果在Game_Actor和Game_Enemy中均找到了它的定义。原来，这个方法不在父类中定义，而是在子类中定义。父类的方法却要用到子类的方法，这不是差辈儿了么？不是这样的，由于父类的高度概括性，导致无法在父类中描述base_maxhp具体的执行过程，而它的两个子类中，描述base_maxhp的执行过程是可以知道的。因此，父类就弄出这么个方法放到这儿，表示我不在这里定义，而是在子类中进行定义。这样只是起说明作用却没有实体的方法叫做“抽象方法”，而在Ruby中，你甚至都不用声明一个抽象方法。</p><p>那允许我再问个问题，如果对Game_Battler类的一个对象调用maxhp方法，则又如何？岂不是要出现No method error？</p><p>要记住，既然是抽象类，一般就不用它去生成一个实例，不生成实例，何谈调用一说啊？RGSS1中出现过Game_Battler.new吗？显然没有。</p><p><strong>第二版更新·完</strong></p><p>当然，如果一个类的方法和属性定义不能满足我们的需求，而我们又不想再定义一个子类，这时候我们就要对原有的类进行扩充。当然，你可以在原来的类上面进行修改，不过，如果是系统整合的话，我们会采用以下的方式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">goodbye</span></span><br><span class="line">    print <span class="string">&quot;See you!&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>注意，Person我们已经在前面定义好了，但是你完全可以再写一遍class Person，表示对该类进行追加定义。</p><p><strong>方法重写(Override)</strong></p><p>如果一个方法已经在父类被定义过，在子类再次对它定义（通常利用父类已有的方法）就叫做方法的重写。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &lt; <span class="title class_ inherited__">Person</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">    print <span class="string">&quot;I am &quot;</span> + <span class="variable">@name</span> + <span class="string">&quot;, and I am a student.&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里我们重写了方法hello，那么在调用student.hello的时候，屏幕上显示的就是新定义叙述的内容（即后面多了and I am a student）。</p><p>不过，这顶多算是把原来的方法覆盖掉了，重写的味道还不是很浓。我们在定义子类方法的时候，通常是对父类的同名方法的扩充，这就要用到关键字super，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &lt; <span class="title class_ inherited__">Person</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:student_id</span> <span class="comment">#定义新属性，学号</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">intialize</span>(<span class="params">name,gender,student_id</span>)</span><br><span class="line">    <span class="variable language_">super</span>(name,gender)</span><br><span class="line">    <span class="variable">@student_id</span> = student_id</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这里，我们调用了Person类的initialize的方法，利用的是关键字super，当然参数什么的不能少。为什么不能写initialize(name,gender)呢？如果这样的话，系统会认为这是一种递归定义，即函数调用自身的过程（Ruby中允许递归定义函数），而并不是调用父类的同名方法，因此我们必须采用这样的形式。</p><p>注意，super关键字的使用有一定特殊性，在使用super的时候，要格外注意参数问题。在这里推荐，即使是被调用的方法没有参数，也要跟一对空括号’()’来表示没有参数，而不能什么都不带直接写super。这是因为，如果super后面什么都不跟，那么默认传进去的参数和正在定义的方法相同，这有可能引起错误。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义父类 A</span></span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable">@a</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 定义子类 B，这里 B 的 initialize 方法中，super的使用是错误的！！</span></span><br><span class="line"><span class="keyword">class</span> B &lt; A</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">b</span>)</span><br><span class="line">    <span class="variable language_">super</span></span><br><span class="line">    <span class="variable">@b</span> = b</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 定义子类 C，这里 C 的 initialize 方法中，super的使用是正确的</span></span><br><span class="line"><span class="keyword">class</span> C &lt; A</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">c</span>)</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable">@c</span> = c</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果有上面的定义，那么在使用B.new时，就会发生Argument Error。</p><p><strong>方法的覆盖</strong></p><p>如果一个方法在一个类中被定义，再次对其定义就叫做方法的覆盖。例如</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">test</span></span><br><span class="line">    p <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a = A.new</span><br><span class="line">a.test <span class="comment"># =&gt; 1</span></span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">test</span></span><br><span class="line">    p <span class="number">2</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a = A.new</span><br><span class="line">a.test <span class="comment"># =&gt; 2</span></span><br></pre></td></tr></table></figure><p>在这里 A 类的方法’test’被定义了两次，那么后定义的会覆盖之前定义的。如果调用A.new.test，实际调用的方法取决于这句话的位置，如果在第一个test后第二个test前使用，那么实际调用的就是覆盖前的方法；如果在第二个test后使用，那么实际调用的就是覆盖后的方法。</p><p>在这一小部分的最后，我想买个关子，在方法的定义和重定义中，还有一个重要的“别名”机制alias，这个东西的存在，为我们写脚本带来了更大灵活性，那么关于alias，我们要放到后面的章节进行讲解，这里就先不说了。</p><p>应大家的要求，我们在这里布置一道小练习题。</p><p>练习：请定义一个表示水瓶的类，水瓶有两个属性，一是最大容积（用一个正整数表示），二是当前水瓶中盛放水的量（也用一个非负整数表示，不得大于最大容积）。在这个类上面定义三个类方法：1.将一个水瓶装满水；2.清空一个水瓶里面的水；3.将这个水瓶自身里面的水倒入另一个水瓶，注意，不是随机地倒，倒完之后，保证自身是空的或者对方是满的。</p><p>定义类class Bottle并验证你定义的方法。</p><p><strong>第二版新增</strong></p><h3 id="1-1-4-模块-module-简介"><a href="#1-1-4-模块-module-简介" class="headerlink" title="*1.1.4  模块(module)简介"></a>*1.1.4  模块(module)简介</h3><p>首先，什么是模块？模块是用于实现某些特定功能的代码的组合。它与类不同，和类相比较，模块内部定义了一些常量和方法，从完整性看，模块不如类完整。不过模块内部可以定义内部类，这样定义的好处是让类的作用更加清楚。</p><p>如何定义一个模块？</p><p>利用关键字module可以定义一个模块。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="title class_">Action</span></span><br><span class="line">  <span class="variable constant_">WORD_ON</span> = <span class="string">&quot;On&quot;</span></span><br><span class="line">  <span class="variable constant_">WORD_OFF</span> = <span class="string">&quot;Off&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">turn_on</span></span><br><span class="line">     print <span class="variable constant_">WORD_ON</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">turn_off</span></span><br><span class="line">     print <span class="variable constant_">WORD_OFF</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这就是一个简单模块的定义。从这几句代码来看，定义了两个字符串常量和两个（普通）方法，而这两个方法，从名字来看是“打开”，“关闭”。可是这有什么用？我们知道，我们可以打开收音机，可以打开电脑，也可以打开煤气灶。那么，对于这几个类，都有相应的“打开”和“关闭”方法。一个个定义显然不妥，我们想到了定义父类。收音机和电脑可以归入到“家用电器(Appliance)”类中，但是煤气灶无论如何也不是什么家用电器。这可咋办？那就定义到更高的父类中，把家用电器和“煤气灶所属的类”归到一个类上去。那我们叫它“家庭用品(Utensils)”类。但是在这个类定义turn_on和turn_off方法，问题就更多了。家庭用品不但包括家用电器，煤气灶，还包括床，被单啥的，难道它们也可“打开关闭”？显然不行。那咋办？</p><p>我们经过观察，可以发现，turn_on和turn_off只是两个特定的功能，和类什么的关系不是很大。于是我们把它定义到模块当中，然后在类中把这个模块糅合进去(Mix-in)。这样，类中便有了模块中实现的方法。</p><p>要在类中糅合模块，要用include方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Radio</span> &lt; <span class="title class_ inherited__">Appliance</span></span><br><span class="line">  <span class="keyword">include</span> <span class="title class_">Action</span></span><br><span class="line">  <span class="built_in">attr_reader</span> <span class="symbol">:brand</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">brand</span>)</span><br><span class="line">    <span class="variable">@brand</span> = brand</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ra = <span class="title class_">Radio</span>.new(<span class="string">&quot;ChangHong&quot;</span>)</span><br><span class="line">ra.turn_on <span class="comment"># =&gt; &quot;On&quot;</span></span><br><span class="line">ra.turn_off <span class="comment"># =&gt; &quot;Off&quot;</span></span><br></pre></td></tr></table></figure><p>这样Radio对象就可以使用Action模块里面的功能。</p><p>啥？不会用？那么我再说个简单的用法好了。Module可以当作命名空间(namespace)使用，主要是各种参数和常量的定义。啥？直接定义在外面？这可不好，万一别人定义的和你自己定义的重复了就麻烦了，还是放到命名空间里面好。我们看看著名的Fuki对话框脚本：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="variable constant_">FUKI</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 头像图片保存目录的设定</span></span><br><span class="line"><span class="variable constant_">HEAD_PIC_DIR</span> = <span class="string">&quot;Graphics/Heads/&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 是否显示尾部图标</span></span><br><span class="line"><span class="variable constant_">TAIL_SHOW</span> = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Skin的设定</span></span><br><span class="line"><span class="comment"># 使用数据库默认窗口Skin情况下这里使用[&quot;&quot;]</span></span><br><span class="line"><span class="variable constant_">FUKI_SKIN_NAME</span> = <span class="string">&quot;skin3&quot;</span>   <span class="comment"># 呼出对话框用Skin</span></span><br><span class="line"><span class="variable constant_">NAME_SKIN_NAME</span> = <span class="string">&quot;skin3&quot;</span>   <span class="comment"># 角色名字窗口用Skin</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 字体大小</span></span><br><span class="line"><span class="variable constant_">MES_FONT_SIZE</span> = <span class="number">22</span>    <span class="comment"># 呼出对话框</span></span><br><span class="line"><span class="variable constant_">NAME_FONT_SIZE</span> = <span class="number">14</span>   <span class="comment"># 角色名字窗口</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 字体颜色</span></span><br><span class="line"><span class="comment">#（设定为 Color.new(0, 0, 0, 0) 表示使用普通文字色）</span></span><br><span class="line"><span class="variable constant_">FUKI_COLOR</span> = <span class="title class_">Color</span>.new(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)  <span class="comment"># 呼出对话框</span></span><br><span class="line"><span class="variable constant_">NAME_COLOR</span> = <span class="title class_">Color</span>.new(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)  <span class="comment"># 角色名字窗口</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 窗口透明度</span></span><br><span class="line"><span class="comment"># 如修改窗口透明度请同时修改尾部箭头图形内部的透明度</span></span><br><span class="line"><span class="variable constant_">FUKI_OPACITY</span> = <span class="number">255</span>    <span class="comment"># 呼出对话框</span></span><br><span class="line"><span class="variable constant_">MES_OPACITY</span> = <span class="number">255</span>     <span class="comment"># 默认信息窗口</span></span><br><span class="line"><span class="variable constant_">NAME_OPACITY</span> = <span class="number">255</span>    <span class="comment"># 角色名字窗口</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 角色名字窗口的相对位置</span></span><br><span class="line"><span class="variable constant_">NAME_SHIFT_X</span> = <span class="number">0</span>      <span class="comment"># 横坐标</span></span><br><span class="line"><span class="variable constant_">NAME_SHIFT_Y</span> = <span class="number">16</span>     <span class="comment"># 纵坐标</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 窗口表示时是否根据画面大小自动检查窗口出现的位置，</span></span><br><span class="line"><span class="comment"># 自动改变位置（ true / false ）</span></span><br><span class="line"><span class="comment"># 设置成 true 可能出现箭头图标颠倒的问题 &lt;- bbschat</span></span><br><span class="line"><span class="variable constant_">POS_FIX</span> = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在画面最边缘表示时的稍微挪动</span></span><br><span class="line"><span class="comment"># 使用圆形Skin的角和方框的角重合的情况下为 true</span></span><br><span class="line"><span class="variable constant_">CORNER_SHIFT</span> = <span class="literal">false</span></span><br><span class="line"><span class="variable constant_">SHIFT_PIXEL</span> = <span class="number">4</span>   <span class="comment"># true 时挪动的象素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 角色高度尺寸</span></span><br><span class="line"><span class="variable constant_">CHARACTOR_HEIGHT</span> = <span class="number">48</span></span><br><span class="line"><span class="comment"># 呼出对话框的相对位置（纵坐标）</span></span><br><span class="line"><span class="variable constant_">POP_SHIFT_TOP</span> = <span class="number">0</span>         <span class="comment"># 表示位置为上的时候</span></span><br><span class="line"><span class="variable constant_">POP_SHIFT_UNDER</span> = <span class="number">0</span>       <span class="comment"># 表示位置为下的时候</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 信息的表示速度（数字越小速度越快，0为瞬间表示）</span></span><br><span class="line"><span class="comment"># 游戏中 可随时用数字代入 $mes_speed 来改变消息表示速度。</span></span><br><span class="line"><span class="variable constant_">MES_SPEED</span> = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Fuki脚本把这些常量都定义到module当中了，他为啥不定义在最外面？显然是考虑冲突的问题。因此我们写脚本也要有这样的习惯，把常量都定义到模块中，不要定义在外面，更不要定义成全局变量。例如（某升级提示脚本）：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$不</span>显示升级窗口 = <span class="number">88</span></span><br></pre></td></tr></table></figure><p> 开始觉得这样没什么，后来越看越觉得不好。</p><p>想要在别的类引用模块内部的常量，要用到’::’运算符。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p <span class="variable constant_">FUKI</span><span class="symbol">:</span><span class="symbol">:Head_PIC_DIR</span></span><br></pre></td></tr></table></figure><p>当然如果一个模块已经被include在类内，就可以在类内部直接用了。</p><p>我又忍不住联想了，其实module这个东西吧，跟接口(Interface)比较相似，都是实现某些特殊功能的语句组合。他们还有一点不谋而合：由于Ruby中无法多重继承（实际上多重继承并不十分合理，个人认为，但是多重继承有可取之处），因此module便可以实现某种意义上的“多重继承”。这点利用接口(Interface)也可以做到。</p><p><strong>第二版更新·完</strong></p><h2 id="1-2-两个重要的类"><a href="#1-2-两个重要的类" class="headerlink" title="1.2  两个重要的类"></a>1.2  两个重要的类</h2><p>在这里我们要介绍两个我们经常用的类。</p><h3 id="1-2-1-数组Array"><a href="#1-2-1-数组Array" class="headerlink" title="1.2.1  数组Array"></a>1.2.1  数组Array</h3><p>数组可以看作是一些对象的有序集合，在内存中占据一块连续的区域。在C语言中，数组有固定长度，而且数组内包含的元素类型必须是相同的。但是在Ruby中，数组运用就灵活了很多。这里的数组不但没有固定的长度，而且内部的元素类型也不必相同。例如：[0,2,nil,[1,2]]，这个数组包含4个元素，从左到右分别是两个整数，nil，还有另一个数组。对数组成员进行访问，直接用下标表示，假如a是一个数组，第0号单元就是a[0]，也就是物理位置上的第一个。下标从0开始而不是从1开始，这个为处理问题提供了很大方便（我一开始也不懂为什么要从0开始，编了四年之后发现这是很方便的）。所以大家还是尽量熟悉它吧。下面我们说下数组常用方法，这个在F1中输入array搜索就能找到。</p><ol><li>初始化<br>a &#x3D; []或者a &#x3D; Array.new<br>别小看这个东西，很多时候因为少了这句话，会引发NoMethodError for nil : NilClass</li><li>将一个元素x放在数组的最后面<br>a.push(x)<br>将数组里面添加元素的常用方法，类似于进栈操作。当然push可以跟很多参数，表示把参数依次添加到数组末尾。</li><li>删除数组中最后一个元素，并返回它<br>element &#x3D; a.pop<br>注意这个函数有两个功能，一是删除，二是取值，类似于出栈操作。</li><li>删除数组中值为val的所有元素<br>a.delete(val)<br>注意，删除之后，所有元素依然是相邻的，下标的位置可能改变。</li><li>删除数组中位置为nth的元素<br>a.delete_at(nth)<br>同上，删除之后其他的元素位置会移动。</li><li>判断数组中是否有元素val<br>include?(val)<br>注意，Ruby中，以’?’结尾的函数的功能约定为判断（当然只是一个约定），返回值要么是true，要么是false。我希望大家也把这个“传统”延续到自己的脚本编写中。</li><li>将数组排序<br>a.sort<br>a.sort!<br>a.sort!{|a,b|…}<br>注意，Ruby中，以’!’结尾的方法称为“重磅方法(Bang Method)”，告诉你这是一个比较危险的方法，很可能破坏原始数据。<br>其中第三个为带块的排序，即按照一定标准排序。例如：a是一个数组，里面元素是我们刚才定义好的Person的实例，现在要将所有元素按照年龄大小排序，那么就要写a.sort!{|a,b| a.age – b.age}。注意，花括号里面的a和b是形式参数，意思就是取好了数组中的两个元素后，再取他们的age属性，和外面的表示数组的a无关。</li><li>遍历整个数组（第二版变更）<br>each{|item| …}<br>each_index{|i| …}<br>each_with_index{|item, index| …}<br>具体块中的操作自己设定。<br>例如：</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>..<span class="number">100</span>).to_a</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line">a.each&#123;|<span class="params">n</span>| s += n&#125;</span><br><span class="line">p s <span class="comment"># =&gt; 5050</span></span><br></pre></td></tr></table></figure><p>each方法就是按照次序取出数组中所有的元素，然后根据元素进行某种操作。</p><p>each_index实际就是对数组的索引进行遍历，作用等同于(0…a.size).to_a.each{|i| …}<br>each_with_index每次把索引和相对应的单元都取出来，以便在块内使用。</p><p>注意：熟悉RGSS1的人喜欢用for item in a~end的形式，其实for是一个语法糖，具体调用的方法还是each，这不过是照顾那些C++的人而设置的。</p><p>注意：使用each迭代器时，不要使用类似于delete这样对原始数组有破坏的方法，这是因为在迭代过程中要尽量保持原有数组的不变性（这种行为在C#里面是不能通过编译的）。</p><h3 id="1-2-2-Hash表"><a href="#1-2-2-Hash表" class="headerlink" title="1.2.2  Hash表"></a>1.2.2  Hash表</h3><pre><code>   Hash表又称关联数组，它相当于在集合A和集合B上建立了一个映射。也就是说，它将A中的每个元素映射到B中。A中的元素成为主键（key），B中的元素称为值（value）。每一个主键都对应唯一一个值。由于主键之间无法排序，所以Hash表也是没有顺序的。   具体的操作大家就自行F1，输入Hash查找一下吧。这里就不多加叙述了。   类的基础知识我们就说完了，肯定不能说的很详细，数组和Hash表的用法，大家如果想知道更多，请参考帮助文件，那说的应该比我要全。在下一章节我们要全局地分析一下RMXP默认的系统，了解一下整个程序究竟是怎样工作的，大家就敬请期待吧！</code></pre><h1 id="第2章节：解密RGSS系统"><a href="#第2章节：解密RGSS系统" class="headerlink" title="第2章节：解密RGSS系统"></a>第2章节：解密RGSS系统</h1><p>在这一章节我们来全局地了解一下我们的RMXP到底是怎么工作的。在这我要说一点题外话，四年前我刚刚接触RMXP，当时年少无知，画了一张地图放上去，就点击那个开始测试按钮，心想会运行出来什么东西，当时的想法是，我除了画了一张地图，什么都没做，大概会运行错误吧，但是实际上，RMXP中已经自带了一个默认的系统。千万别小看这个系统，虽然功能还不够强大，但是作为我们学习的例子，肯定是十分合适的。</p><p>注意啦，从这节之后，我们要具体学习如何解读RMXP的脚本和改造它，甚至我们可以自行编写脚本，这就是我写这个帖子的目的所在。</p><h2 id="2-1-预置脚本"><a href="#2-1-预置脚本" class="headerlink" title="2.1  预置脚本"></a>2.1  预置脚本</h2><p>打开RMXP的脚本编辑器，我们就会看到一堆乱七八糟的代码。心里不禁有一些发虚，我相信，即使有些朋友看了很多次F1，对着这些脚本也会一头雾水。没关系，我们一点点梳理一下它们的层次。</p><h3 id="2-1-1-Game-Xxxx游戏对象脚本"><a href="#2-1-1-Game-Xxxx游戏对象脚本" class="headerlink" title="2.1.1  Game_Xxxx游戏对象脚本"></a>2.1.1  Game_Xxxx游戏对象脚本</h3><p><img src="/posts/2347af05/2-1.png"><br>上面图片显示的就是游戏对象的脚本，游戏对象，就是在游戏进行过程中，和玩家互动的对象。比方说游戏地图，地图上的事件，发生打斗的敌人等等。这些对象都随着游戏进行而变化。与之相对的是数据脚本，这就是我们所说的数据库，它们是游戏开始之前就已经设置好的数据，一般是不可更改的。我们打开RMXP，很长时间都会花在游戏数据编辑上面。（比方说道具，武器，职业，状态，都是我们自己定义的，并且游戏进行中不会更改）</p><p>那了解这部分内容，我们想想在整个游戏中都会遇到什么东西。</p><p>首先是游戏的系统对象，比方说计时器，比方说各种音乐音效，这些对象的管理在Game_System中，我们打开这个脚本，就可以清楚地看到，这个脚本执行的是什么功能。当进入游戏画面中，系统会载入一个Game_System类的实例$game_system，这个全局变量是游戏中一直存在的，直到你退出游戏。而使用Game_System类的方法，就要利用$game_system这个实例。</p><p>例如，要让游戏播放一个BGM，就要输入：</p><p>$game_system.bgm_play(bgm)，其中，bgm是代表一个音频对象（并不是指BGM的文件名），我们实际运用的时候，通常会调用这样的语句：</p><p>Audio.bgm_play(filename,volume,pitch)，三个参数表示文件名，音量，节拍，后面两个参数可以省略。Audio其实是一个模块，我们初学还暂时用不到它的概念，我们只需要记住这样用就可以了。</p><p>然后就是各种游戏开关和变量了，这些东西，就是我们在编写事件的时候用的，实际上游戏在运行时，也会创建它们。不过，这个东西可不是游戏一打开就有的，只是在开始新游戏或者载入存档之后才有的。原因也很简单，因为无论是开关还是变量，都是在玩家真正开始游戏的时候才有存在的意义，而在标题处是没有它的实际作用的。换言之，如果你想用某个开关的变换来改变标题画面的一些东西（比方说打开1号开关读档按钮无效，关闭1号开关读档按钮有效），这样的思路是行不通的。</p><ul><li>Game_Switches——游戏开关的类</li><li>Game_SelfSwitches——游戏独立开关的类</li><li>Game_Variables——游戏变量的类</li></ul><p>这三个类就是表示开关，独立开关，变量。对应生成的实例是：</p><ul><li>$game_switches</li><li>$game_self_switches</li><li>$game_variables</li></ul><p>当然，这些东西只有真正进行游戏时才会有的。下面我们来一个个说该怎么用。</p><p>$game_switches和$game_variables都是类似于数组的结构，我们可以像数组那样使用它。不过仅限于读取和改写两种操作，其余的类似于删除之类的操作则无法进行。<br>因为数组是从0号单元开始，但是游戏设定里面，ID是从1开始的，因此这两个全局变量的0号单元都是nil，我们用的时候，不必担心这方面的问题。$game_switches[1]就是指的1号开关（事件编译器中的1号开关），$game_variables[1]就是指的1号变量。</p><p>$game_self_switches是类似于Hash表的结构，我们可以像Hash表那样使用它。当然，我们也不能使用Hash表的全部功能，仅限于读取和改写两种操作而已。<br>这个Hash表中的主键的类型，是一个含有3个元素的数组（Hash表的若干概念可以自行F1），[map_id,event_id,switch_tag]，其中，第一个元素指的是地图ID，第二个元素指的是事件ID，第三个元素指的是开关编号（因为同一个事件的独立开关有4个，分别是A，B，C，D），这样某一个独立开关的信息就会完全确定。因此，让1号地图ID为2的事件的独立开关A打开，就要写：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$game_self_switches</span>[[<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;A&#x27;</span>]] = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>注意，最后一个参数是单引号引出的大写字母。</p><p>我们知道，如果利用事件编辑器，只能对本事件的独立开关进行操作，但是，有了上面这个语句，我们便可以在一个事件中对另一个事件的独立开关进行操作，这样能解决很多问题。</p><p>那么在这里我们留下一个小小的作业。</p><p>【踩冰机关】请尽量用事件编写一个小游戏，主角踏入一片奇怪的冰地，冰地上有一个入口和一个出口，只有主角把规定区域内所有的地面都踩过一次（规定不允许重复踩踏规定区域内的任何一个地面，即所有地面必须踩一次而且只能踩一次），出口才会打开，否则出口不会打开。当主角踩踏某一块地面两次时，宣布失败，利用场所移动将主角传送到入口，并且重置地面（如果主角没有把地面全踩一遍就走到出口，按照规则，出口是封闭的，这时候主角只能第二次踩出口的那块地面，因此游戏也会失败）。允许使用的脚本仅限于对独立开关的操作。小提示：实际上，在地面块数比较少的情况下，利用开关也是可以做到的，但是开关的数量实在是太少，会造成很多浪费，在这里我们会看出独立开关的优越性。</p><p>最后要说的是，这三个全局变量，每次存档后，都会写入存档文件里面，利用这个特性，我们可以做出很多新的脚本，具体的还要到后面我们再说。</p><p>还有就是队伍，角色，敌人队伍，敌人。</p><ul><li>Game_Battler——游戏战斗者的类，分成3部分定义，是Game_Actor和Game_Enemy的父类</li><li>Game_Actor——角色的类</li><li>Game_Enemy——敌人的类</li><li>Game_Troop——敌人队伍的类</li><li>Game_Party——角色队伍的类</li><li>tors——角色排列的类</li><li>Game_BattleAction——打斗行动的类，在Game_Battler内部使用</li></ul><p>其中，拥有全局变量实例，并且全局变量能写入存档的是</p><ul><li>$game_party #表示角色队伍</li><li>$game_actors #表示角色排列</li><li>$game_troop #表示敌人队伍</li></ul><p>这些内容，我们会在第3章节重点讲解，因为这里是大家对游戏的改动涉及最多的地方，因此我们肯定会详细说的，在这儿只是让大家了解个大概。</p><p>注意，Game_Actors和Game_Actor是两个不同的东西，Game_Actors是类似于数组的类，$game_actors里面是按照角色ID存放各个角色的信息，而Game_Actor则是活生生的角色类，因此使用的时候不要弄混了（话说我刚写脚本的时候就经常弄混）。</p><p>再有就是游戏地图，角色和事件，公共事件了。这些都是在地图上要处理的，而且非常直观。</p><ul><li>Game_Map——游戏地图的类</li><li>Game_Character——角色和事件公用的父类，分成3部分定义</li><li>Game_Player——角色（在地图上）的类</li><li>Game_Event——事件（在地图上）的类</li><li>Game_CommonEvent——公共事件的类</li></ul><p>其中，拥有全局变量实例，并且能被写入存档的是</p><ul><li>$game_map #表示游戏地图</li><li>$game_player #表示地图上玩家的角色</li></ul><p>这里要说明的是，游戏的各种事件是地图里面附属的一个东西，因此只需要放在$game_map里面就可以了，至于为什么把玩家单单提出来做成一个类，是因为玩家和事件有着不同性质。</p><p>另外是游戏画面，游戏图片。</p><ul><li>Game_Screen——游戏画面的类</li><li>Game_Picture——图片的类</li></ul><p>其中$game_screen会被写入存档数据。</p><p>Game_Screen是负责游戏画面闪烁，震动，色调变换，或者是天气设置的，这个肯定和地图不同，因此和Game_Map是分开的。</p><p>Game_Picture是在$game_screen内部使用，事件编辑器里面的显示图片什么的，其实就是这个类的方法。这里我们改脚本改动较少，所以就在这里说一下而已。</p><p>最后，游戏需要什么临时数据，比方说是否在战斗中啦，是否由事件调用存档啦，都是临时数据。这些临时数据统统放在一个类的实例里面。</p><p>Game_Temp——游戏临时数据的类<br>对应实例是$game_temp<br>因为是临时数据，当然不会写入存档中，这个大家一定要注意。很多人写了新脚本，却把需要存储的数据放到$game_temp里面去，结果可想而知。</p><h3 id="2-1-2-Sprite-Xxxx-Spriteset-Xxxx精灵-活动块-活动块组"><a href="#2-1-2-Sprite-Xxxx-Spriteset-Xxxx精灵-活动块-活动块组" class="headerlink" title="2.1.2  Sprite_Xxxx Spriteset_Xxxx精灵 活动块 活动块组"></a>2.1.2  Sprite_Xxxx Spriteset_Xxxx精灵 活动块 活动块组</h3><p>![]{2-2.png}</p><p>实际上，游戏中显示到屏幕上的图片，都是由这些类生成的，不要以为$game_map表示地图，那么地图就是$game_map，实际上，负责生成并且显示图片的工作，是交给精灵（Sprite）完成的。</p><ul><li>Sprite_Character——角色行走图活动块类，包括主角和事件的行走图</li><li>Sprite_Battler——战斗图活动块类，包括主角和敌人的战斗图</li><li>Sprite_Picture——图片活动块类</li><li>Sprite_Timer——计时器活动块类</li><li>Spriteset_Map——地图元件活动块组，是一些活动块的集合体，例如地图元件，角色行走图，远景图，雾图形，计时器</li><li>Spriteset_Battle——战斗画面活动块组，是一些活动块集合体，例如战斗图，战斗背景，计时器</li></ul><p>在这里我们只讲一个事情，很多人会发现，数据库中能够更改敌人战斗图的位置，却不能更改主角的战斗图位置，这是非常不方便的事情。那么怎样改变角色战斗图的位置呢？我开始以为答案在Sprite_Battler或者Spriteset_Battle里面，后来一看根本就不是，其实角色战斗图的位置在Game_Actor中的第567行（如果脚本是默认的）：<br><img src="/posts/2347af05/2-3.png"></p><p>这下就可以改脚本了，这是竖版战斗改横版战斗或者45度角战斗的第一步啊！</p><h3 id="2-1-3-Window-Xxxx窗口类"><a href="#2-1-3-Window-Xxxx窗口类" class="headerlink" title="2.1.3  Window_Xxxx窗口类"></a>2.1.3  Window_Xxxx窗口类</h3><p><img src="/posts/2347af05/2-4.png"><br>这也是游戏中非常重要的一个类了，以后我们经常会跟它打交道。游戏里面所有带框框的基本都是这个类的实例，其中第三个Window_Selectable改，是我优化了Window_Selectable之后的脚本，原来的默认脚本是没有的。当然，窗口我们也是重点讲，不过还是不在这一章，因此大家翻开看看就好，起码知道每个脚本都是负责什么窗口的。</p><h3 id="2-1-4-Arrow-Xxxx光标类脚本"><a href="#2-1-4-Arrow-Xxxx光标类脚本" class="headerlink" title="2.1.4  Arrow_Xxxx光标类脚本"></a>2.1.4  Arrow_Xxxx光标类脚本</h3><p>这个图我就不截了，如果是没有鼠标脚本的话，这个地方大家应该不会动（实际上我也没怎么动过）。这个类的内容，就是负责游戏里战斗场面指敌人或者指主角的光标，而不是窗口中的光标矩形，这个大家注意下就好。</p><h3 id="2-1-5-Interpreter事件解释器脚本"><a href="#2-1-5-Interpreter事件解释器脚本" class="headerlink" title="2.1.5  Interpreter事件解释器脚本"></a>2.1.5  Interpreter事件解释器脚本</h3><p><img src="/posts/2347af05/2-5.png"><br>这个大概是脚本编辑器最庞大的脚本了吧，分割定义就有7个之多。而他们的作用，我不用多说，是事件党的最爱了吧。事件编辑器中所有的指令，都是这里的方法，说白了，RMXP把我们最常用的命令放到事件编辑器中，可以进行“傻瓜式”操作。</p><p>当然，有些脚本就是对这些事件指令进行优化，比如我们熟知的物品得失提示脚本，就是更改了Interpreter类里面的内容。这个我们后面也要作详细说明。</p><h3 id="2-1-6-Scene-Xxxx场景类脚本"><a href="#2-1-6-Scene-Xxxx场景类脚本" class="headerlink" title="2.1.6  Scene_Xxxx场景类脚本"></a>2.1.6  Scene_Xxxx场景类脚本</h3><p><img src="/posts/2347af05/2-6.png"><br>这也是我们经常会遇到的脚本，它们的作用就是处理一个个组合的场景。简单来说，一个场景包括很多个窗口，精灵，以及对所有输入的回应。注意，特别是对输入的回应，是在场景中进行的，也就是说，Window_Selectable定义的时候，并没有说输入空格或者回车后，窗口该怎么怎么变。真正对输入的反应，是在Scene中进行，因为一个场景的很多“元件”都是相关联的的，用一个场景统一处理他们，才是最好的选择。</p><p>同样，我们在后面的章节，要重点讲场景的制作。</p><h3 id="2-1-7-Main游戏脚本的入口"><a href="#2-1-7-Main游戏脚本的入口" class="headerlink" title="2.1.7  Main游戏脚本的入口"></a>2.1.7  Main游戏脚本的入口</h3><p>在脚本的最后我们看到一个叫Main的脚本，翻开它，我们会看到只有短短的几行。这就相当于RGSS的主函数，整个程序就是从主函数出发来向下进行的。</p><p>另外，在Main之前的位置，是我们插入各种外挂脚本的地方，我们不能随便地插入到脚本编辑器的任意位置，只能插到Main组之前，Scene组之后，这点大家一定要注意。</p><h2 id="2-2-RGSS的工作过程"><a href="#2-2-RGSS的工作过程" class="headerlink" title="2.2  RGSS的工作过程"></a>2.2  RGSS的工作过程</h2><p>实际上，脚本编译的顺序就是从上至下。注意，此时程序还未开始运行，Main组前面所有的脚本，都是进行各种变量和方法的定义，因此它们也只是静静地躺在那里。真正开始的是Main组中的脚本。</p><p>那我们先看看Main组脚本里面都有什么：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment"># 准备过渡</span></span><br><span class="line">  <span class="comment"># 设置系统默认字体</span></span><br><span class="line">  <span class="title class_">Font</span>.default_name = ([<span class="string">&quot;黑体&quot;</span>])</span><br><span class="line">  <span class="title class_">Graphics</span>.freeze</span><br><span class="line">  <span class="comment"># 生成场景对像 (标题画面)</span></span><br><span class="line">  <span class="variable">$scene</span> = <span class="title class_">Scene</span>_Title.new</span><br><span class="line">  <span class="comment"># $scene 为有效的情况下调用 main 过程</span></span><br><span class="line">  <span class="keyword">while</span> <span class="variable">$scene</span> != <span class="literal">nil</span></span><br><span class="line">    <span class="variable">$scene</span>.main</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 淡入淡出</span></span><br><span class="line">  <span class="title class_">Graphics</span>.transition(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">rescue</span> <span class="title class_">Errno</span><span class="symbol">:</span><span class="symbol">:ENOENT</span></span><br><span class="line">  <span class="comment"># 补充 Errno::ENOENT 以外错误</span></span><br><span class="line">  <span class="comment"># 无法打开文件的情况下、显示信息后结束</span></span><br><span class="line">  filename = <span class="variable">$!</span>.message.sub(<span class="string">&quot;No such file or directory - &quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">  print(<span class="string">&quot;找不到文件 <span class="subst">#&#123;filename&#125;</span>。 &quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>一开始先简短设置系统字体，准备画面过渡。</p><p>然后就直接进入场景画面。</p><p>注意，那个$scene是伴随这程序始终进行的全局变量，表示的就是当前场景本身。中间那个while循环是说，如果$scene的值不是nil，那么就调用$scene的main方法。也就是说，如果想退出这个循环，直接输入$scene &#x3D; nil即可，这样的话，不但场景会退出，主函数也会跟着结束，因此整个游戏就退出了。</p><p>在这里$scene一开始被赋予Scene_Title.new，也就是说我们即将进入标题画面，调用的也是标题画面的main方法。</p><p>我们于是打开Scene_Title，在这里我就不放全部代码了。可以看到有下面的语句：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$data_actors</span>        = load_data(<span class="string">&quot;Data/Actors.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_classes</span>       = load_data(<span class="string">&quot;Data/Classes.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_skills</span>        = load_data(<span class="string">&quot;Data/Skills.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_items</span>         = load_data(<span class="string">&quot;Data/Items.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_weapons</span>       = load_data(<span class="string">&quot;Data/Weapons.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_armors</span>        = load_data(<span class="string">&quot;Data/Armors.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_enemies</span>       = load_data(<span class="string">&quot;Data/Enemies.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_troops</span>        = load_data(<span class="string">&quot;Data/Troops.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_states</span>        = load_data(<span class="string">&quot;Data/States.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_animations</span>    = load_data(<span class="string">&quot;Data/Animations.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_tilesets</span>      = load_data(<span class="string">&quot;Data/Tilesets.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_common_events</span> = load_data(<span class="string">&quot;Data/CommonEvents.rxdata&quot;</span>)</span><br><span class="line"><span class="variable">$data_system</span>        = load_data(<span class="string">&quot;Data/System.rxdata&quot;</span>)</span><br></pre></td></tr></table></figure><p>这就是在游戏一开始，载入所有游戏数据库内所有数据，并保存在相应的全局变量里面。这些全局变量不会被更改，一直存在直到游戏退出。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">command_new_game</span></span><br><span class="line">    <span class="comment"># 演奏确定 SE</span></span><br><span class="line">    <span class="variable">$game_system</span>.se_play(<span class="variable">$data_system</span>.decision_se)</span><br><span class="line">    <span class="comment"># 停止 BGM</span></span><br><span class="line">    <span class="title class_">Audio</span>.bgm_stop</span><br><span class="line">    <span class="comment"># 重置测量游戏时间用的画面计数器</span></span><br><span class="line">    <span class="title class_">Graphics</span>.frame_count = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 生成各种游戏对像</span></span><br><span class="line">    <span class="variable">$game_temp</span>          = <span class="title class_">Game</span>_Temp.new</span><br><span class="line">    <span class="variable">$game_system</span>        = <span class="title class_">Game</span>_System.new</span><br><span class="line">    <span class="variable">$game_switches</span>      = <span class="title class_">Game</span>_Switches.new</span><br><span class="line">    <span class="variable">$game_variables</span>     = <span class="title class_">Game</span>_Variables.new</span><br><span class="line">    <span class="variable">$game_self_switches</span> = <span class="title class_">Game</span>_SelfSwitches.new</span><br><span class="line">    <span class="variable">$game_screen</span>        = <span class="title class_">Game</span>_Screen.new</span><br><span class="line">    <span class="variable">$game_actors</span>        = <span class="title class_">Game</span>_Actors.new</span><br><span class="line">    <span class="variable">$game_party</span>         = <span class="title class_">Game</span>_Party.new</span><br><span class="line">    <span class="variable">$game_troop</span>         = <span class="title class_">Game</span>_Troop.new</span><br><span class="line">    <span class="variable">$game_map</span>           = <span class="title class_">Game</span>_Map.new</span><br><span class="line">    <span class="variable">$game_player</span>        = <span class="title class_">Game</span>_Player.new</span><br><span class="line">    <span class="comment"># 设置初期同伴位置</span></span><br><span class="line">    <span class="variable">$game_party</span>.setup_starting_members</span><br><span class="line">    <span class="comment"># 设置初期位置的地图</span></span><br><span class="line">    <span class="variable">$game_map</span>.setup(<span class="variable">$data_system</span>.start_map_id)</span><br><span class="line">    <span class="comment"># 主角向初期位置移动</span></span><br><span class="line">    <span class="variable">$game_player</span>.moveto(<span class="variable">$data_system</span>.start_x, <span class="variable">$data_system</span>.start_y)</span><br><span class="line">    <span class="comment"># 刷新主角</span></span><br><span class="line">    <span class="variable">$game_player</span>.refresh</span><br><span class="line">    <span class="comment"># 执行地图设置的 BGM 与 BGS 的自动切换</span></span><br><span class="line">    <span class="variable">$game_map</span>.autoplay</span><br><span class="line">    <span class="comment"># 刷新地图 (执行并行事件)</span></span><br><span class="line">    <span class="variable">$game_map</span>.update</span><br><span class="line">    <span class="comment"># 切换地图画面</span></span><br><span class="line">    <span class="variable">$scene</span> = <span class="title class_">Scene</span>_Map.new</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以新游戏命令为例，当玩家选择“新游戏”时，系统会做以上工作。</p><p>其中我们看到直到这里才会生成各个游戏对象，如果是载入，那么就会载入各种游戏对象。</p><p>最后一步将场景切换到地图场景中。这里把$scene变成Scene_Map.new，在所有场景的main函数中，都有一个无限循环loop do，其中有一句：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable">$scene</span> != <span class="variable language_">self</span></span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的self是指被处理对象实例本身，刚才我们说$scene &#x3D; Scene_Map.new，这就是所谓的$scene不再是被处理对象本身了，变成了其它的东西，表达式不满足，跳出main的主循环loop do。而后，我们回到Main组那里，$scene.main这个语句已经执行完毕，但是不满足循环终止的条件，即$scene还不是nil，因此Main组里面继续调用新的$scene的main方法，这时候$scene已经是Scene_Map的实例了，因此画面就会转到地图画面。</p><p>整个游戏就是这样工作的。直到$scene &#x3D;&#x3D; nil，游戏便终止了。</p><p>第2章节的内容就到这里，接下来的第3章，我们要系统学习如何DIY游戏对象脚本Game_Xxxx，大家就敬请期待吧。</p><h1 id="第3章节：改动游戏对象"><a href="#第3章节：改动游戏对象" class="headerlink" title="第3章节：改动游戏对象"></a>第3章节：改动游戏对象</h1><p>从这一章节开始我们要具体说说如何在原脚本的基础上改动脚本，甚至你可以自己做出一个脚本。如果你前面的概念不是很明白的话，没有关系，不过只要你关注这里的话，相信你一定能够成功写出一个脚本的。</p><h2 id="3-1-战斗者-Game-Battler-角色队伍-Game-Party"><a href="#3-1-战斗者-Game-Battler-角色队伍-Game-Party" class="headerlink" title="3.1  战斗者(Game_Battler) 角色队伍(Game_Party)"></a>3.1  战斗者(Game_Battler) 角色队伍(Game_Party)</h2><h3 id="3-1-1-Game-Battler-Game-Actor-（角色类）Game-Enemy（敌人类）"><a href="#3-1-1-Game-Battler-Game-Actor-（角色类）Game-Enemy（敌人类）" class="headerlink" title="3.1.1  Game_Battler Game_Actor （角色类）Game_Enemy（敌人类）"></a>3.1.1  Game_Battler Game_Actor （角色类）Game_Enemy（敌人类）</h3><p>作为可以出现在战斗中的对象，RGSS将角色和敌人分别定义，再根据他们的共同性质（比方说都有HP，都可以进行技能伤害等等）定义出一个父类Game_Battler。那我们先翻开Game_Battler，看看这里面的结构究竟是什么。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">attr_reader</span>   <span class="symbol">:battler_name</span>             <span class="comment"># 战斗者 文件名</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:battler_hue</span>              <span class="comment"># 战斗者 色相</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:hp</span>                       <span class="comment"># HP</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:sp</span>                       <span class="comment"># SP</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:states</span>                   <span class="comment"># 状态</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:hidden</span>                   <span class="comment"># 隐藏标志</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:immortal</span>                 <span class="comment"># 不死身标志</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:damage_pop</span>               <span class="comment"># 显示伤害标志</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:damage</span>                   <span class="comment"># 伤害值</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:critical</span>                 <span class="comment"># 会心一击标志</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:animation_id</span>             <span class="comment"># 动画 ID</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:animation_hit</span>            <span class="comment"># 动画 击中标志</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:white_flash</span>              <span class="comment"># 白色屏幕闪烁标志</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:blink</span>                    <span class="comment"># 闪烁标志</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 初始化对像</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="variable">@battler_name</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="variable">@battler_hue</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable">@hp</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable">@sp</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable">@states</span> = []</span><br><span class="line">    <span class="variable">@states_turn</span> = &#123;&#125;</span><br><span class="line">    <span class="variable">@maxhp_plus</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable">@maxsp_plus</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable">@str_plus</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable">@dex_plus</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable">@agi_plus</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable">@int_plus</span> = <span class="number">0</span></span><br><span class="line">    [url=home.php?mod=space&amp;uid=<span class="number">292300</span>]<span class="variable">@Hidden</span>[<span class="regexp">/url] = false</span></span><br><span class="line"><span class="regexp">    @immortal = false</span></span><br><span class="line"><span class="regexp">    @damage_pop = false</span></span><br><span class="line"><span class="regexp">    @damage = nil</span></span><br><span class="line"><span class="regexp">    @critical = false</span></span><br><span class="line"><span class="regexp">    @animation_id = 0</span></span><br><span class="line"><span class="regexp">    @animation_hit = false</span></span><br><span class="line"><span class="regexp">    @white_flash = false</span></span><br><span class="line"><span class="regexp">    @blink = false</span></span><br><span class="line"><span class="regexp">    @current_action = Game_BattleAction.new</span></span><br><span class="line"><span class="regexp">  end</span></span><br></pre></td></tr></table></figure><p>我们先看attr属性定义的部分。<br>battler_name和battler_hue是战斗图的文件名和色相，这个大家一般不用管，都是在数据库里面设置好的。<br>states指的是当前战斗者被附加上的状态的ID，是一个数组。<br>hidden和immortal指的是敌人的专有属性，分别是是否隐藏（就是中途出现）和不死之身标志，这个也是在数据库定义的。虽然定义在了Game_Battler里面，但是如果是Game_Actor的实例，使用这两个属性是无效的。<br>damage是别的战斗者对自身造成的伤害，注意，并非自己的某种战斗行动给他人造成的伤害。</p><p>我们再看initialize方法部分。</p><p>我们会发现，这里面多了几个没有声明成属性的实变量。证明这些变量是没有公开的。</p><p>@states_turn是一个Hash，里面存放的是当前具有的状态距离自动解除还需要的回合数。这里用Hash表而不用数组是因为考虑到一个战斗者身上的状态毕竟是少数，用Hash可以更加灵活。比方说1号状态经过3回合才能进行自动解除（注意，自动解除并不是真正解除，而是数据库中的这个部分：<br><img src="/posts/2347af05/3-1.png"><br> ），</p><p>那么@states_turn[1]的值就是3。这样每过一个回合，所有状态的剩余回合都-1，达到0的进行自动解除。另外，如果这里的一个主键的值是-1，那么它是一个自动状态（就是防具附加的状态），这种状态是不进入自动解除的，除非你卸下防具。</p><p>@maxhp_plus，@maxsp_plus等6个属性值的是各种能力值的加成，这些变量也是针对角色来说的，主要是在用事件增加角色的能力值或者用道具增加能力值的时候，储存增加的量。注意这些值和等级是没有关系的。</p><p>我们来看看下面的几个方法。</p><p>细心的朋友可能发现，在这个类别中，没有写类似于attr_accessor :maxhp这样的东西，这是因为attr_accessor只是定义简单读取和写入操作，并没有其它的功能。而我们知道，一个角色的maxhp，取决于他的等级，状态，能力值加成等等，如果只是简单定义attr_accessor :maxhp，这样对maxhp进行更改就会变得很复杂，倒不如直接一次性取得所有的因素。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxhp</span></span><br><span class="line">    n = [[base_maxhp + <span class="variable">@maxhp_plus</span>, <span class="number">1</span>].max, <span class="number">999999</span>].min</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">@states</span></span><br><span class="line">      n *= <span class="variable">$data_states</span>[i].maxhp_rate / <span class="number">100.0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    n = [[<span class="title class_">Integer</span>(n), <span class="number">1</span>].max, <span class="number">999999</span>].min</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里我们可以看到，获取maxhp的第一步，是计算基础maxhp和加成maxhp的和，再进行范围修正。第二步是进行状态的修正，我们知道，在数据库中的状态一栏，我们可以通过状态来改变maxhp值。最后那个n &#x3D; [[Integer(n),1].max,999999].min表示先把n变成整数，然后再进行属性修正。</p><p>在这里，我们发现在第二行有个base_maxhp，很多人会好奇这是个什么东西，不是实变量，在Game_Battler里面也找不到相应的方法，更不可能是局部变量。其实，这个东西确实是一个方法，但是不是在Game_Battler中，而是在它的两个子类Game_Actor和Game_Enemy中，因为两个子类对应的方法不一样，所以要分开定义。这就意味着虽然这个方法看似在这个类中没出现，但是如果我们在其子类中定义了它，则仍然可以在子类中使用。在后面我们会看到它的庐山真面目。<br>R</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_action_speed</span></span><br><span class="line">    <span class="variable">@current_action</span>.speed = agi + rand(<span class="number">10</span> + agi / <span class="number">4</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个方法的作用是决定战斗者的行动速度，即速度越大的越先行动。agi是战斗者的速度，后面那个是上下浮动的随机分散值。这就说明了一个战斗者速度对行动先后的重要性。这也能说明，速度大的战斗者行动的顺序很可能排到前面（受到后面浮动随机分散的影响）。因此我们如果要更改这种排序模式，改变这个方法就OK。</p><p>然后就是这个增加状态的方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_state</span>(<span class="params">state_id, force = <span class="literal">false</span></span>)</span><br><span class="line">    <span class="comment"># 无效状态的情况下</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$data_states</span>[state_id] == <span class="literal">nil</span></span><br><span class="line">      <span class="comment"># 过程结束</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 无法强制附加的情况下</span></span><br><span class="line">    <span class="keyword">unless</span> force</span><br><span class="line">      <span class="comment"># 已存在的状态循环</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">@states</span></span><br><span class="line">        <span class="comment"># 新的状态和已经存在的状态 (-) 同时包含的情况下、</span></span><br><span class="line">        <span class="comment"># 本状态不包含变化为新状态的状态变化 (-) </span></span><br><span class="line">        <span class="comment"># (ex : 战斗不能与附加中毒同时存在的场合)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable">$data_states</span>[i].minus_state_set.<span class="keyword">include</span>?(state_id) <span class="keyword">and</span></span><br><span class="line">           <span class="keyword">not</span> <span class="variable">$data_states</span>[state_id].minus_state_set.<span class="keyword">include</span>?(i)</span><br><span class="line">          <span class="comment"># 过程结束</span></span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 无法附加本状态的情况下</span></span><br><span class="line">    <span class="keyword">unless</span> state?(state_id)</span><br><span class="line">      <span class="comment"># 状态 ID 追加到 <span class="doctag">@states</span> 序列中</span></span><br><span class="line">      <span class="variable">@states</span>.push(state_id)</span><br><span class="line">      <span class="comment"># 选项 [当作 HP 0 的状态] 有效的情况下</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">$data_states</span>[state_id].zero_hp</span><br><span class="line">        <span class="comment"># HP 更改为 0</span></span><br><span class="line">        <span class="variable">@hp</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="comment"># 所有状态的循环</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="variable">$data_states</span>.size</span><br><span class="line">        <span class="comment"># 状态变化 (+) 处理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable">$data_states</span>[state_id].plus_state_set.<span class="keyword">include</span>?(i)</span><br><span class="line">          add_state(i)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment"># 状态变化 (-) 处理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable">$data_states</span>[state_id].minus_state_set.<span class="keyword">include</span>?(i)</span><br><span class="line">          remove_state(i)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="comment"># 按比例大的排序 (值相等的情况下按照强度排序)</span></span><br><span class="line">      <span class="variable">@states</span>.sort! <span class="keyword">do</span> |<span class="params">a, b</span>|</span><br><span class="line">        state_a = <span class="variable">$data_states</span>[a]</span><br><span class="line">        state_b = <span class="variable">$data_states</span>[b]</span><br><span class="line">        <span class="keyword">if</span> state_a.rating &gt; state_b.rating</span><br><span class="line">          -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elsif</span> state_a.rating &lt; state_b.rating</span><br><span class="line">          +<span class="number">1</span></span><br><span class="line">        <span class="keyword">elsif</span> state_a.restriction &gt; state_b.restriction</span><br><span class="line">          -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elsif</span> state_a.restriction &lt; state_b.restriction</span><br><span class="line">          +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          a &lt;=&gt; b</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 强制附加的场合</span></span><br><span class="line">    <span class="keyword">if</span> force</span><br><span class="line">      <span class="comment"># 设置为自然解除的最低回数 -1 (无效)</span></span><br><span class="line">      <span class="variable">@states_turn</span>[state_id] = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 不能强制附加的场合</span></span><br><span class="line">    <span class="keyword">unless</span>  <span class="variable">@states_turn</span>[state_id] == -<span class="number">1</span></span><br><span class="line">      <span class="comment"># 设置为自然解除的最低回数</span></span><br><span class="line">      <span class="variable">@states_turn</span>[state_id] = <span class="variable">$data_states</span>[state_id].hold_turn</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 无法行动的场合</span></span><br><span class="line">    <span class="keyword">unless</span> movable?</span><br><span class="line">      <span class="comment"># 清除行动</span></span><br><span class="line">      <span class="variable">@current_action</span>.clear</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 检查 HP 及 SP 的最大值</span></span><br><span class="line">    <span class="variable">@hp</span> = [<span class="variable">@hp</span>, <span class="variable language_">self</span>.maxhp].min</span><br><span class="line">    <span class="variable">@sp</span> = [<span class="variable">@sp</span>, <span class="variable language_">self</span>.maxsp].min</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">states_plus</span>(<span class="params">plus_state_set</span>)</span><br><span class="line">    <span class="comment"># 清除有效标志</span></span><br><span class="line">    effective = <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 循环 (附加状态)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> plus_state_set</span><br><span class="line">      <span class="comment"># 无法防御本状态的情况下</span></span><br><span class="line">      <span class="keyword">unless</span> <span class="variable language_">self</span>.state_guard?(i)</span><br><span class="line">        <span class="comment"># 这个状态如果不是 full 的话就设置有效标志</span></span><br><span class="line">        effective |= <span class="variable language_">self</span>.state_full?(i) == <span class="literal">false</span></span><br><span class="line">        <span class="comment"># 状态为 [不能抵抗] 的情况下</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable">$data_states</span>[i].nonresistance</span><br><span class="line">          <span class="comment"># 设置状态变化标志</span></span><br><span class="line">          <span class="variable">@state_changed</span> = <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 附加状态</span></span><br><span class="line">          add_state(i)</span><br><span class="line">        <span class="comment"># 这个状态不是 full 的情况下</span></span><br><span class="line">        <span class="keyword">elsif</span> <span class="variable language_">self</span>.state_full?(i) == <span class="literal">false</span></span><br><span class="line">          <span class="comment"># 将状态的有效度变换为概率、与随机数比较</span></span><br><span class="line">          <span class="keyword">if</span> rand(<span class="number">100</span>) &lt; [<span class="number">0</span>,<span class="number">100</span>,<span class="number">80</span>,<span class="number">60</span>,<span class="number">40</span>,<span class="number">20</span>,<span class="number">0</span>][<span class="variable language_">self</span>.state_ranks[i]]</span><br><span class="line">            <span class="comment"># 设置状态变化标志</span></span><br><span class="line">            <span class="variable">@state_changed</span> = <span class="literal">true</span></span><br><span class="line">            <span class="comment"># 附加状态</span></span><br><span class="line">            add_state(i)</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 过程结束</span></span><br><span class="line">    <span class="keyword">return</span> effective</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这是将战斗者自身增加状态的两个方法，第二个方法调用了第一个方法，而第一个方法是增加单个状态ID为state_id的状态，先是判断状态是否无效（即定义到了$data_states之外），然后是判断战斗者身上有没有抵抗这种状态的另一种状态（例如，“战斗不能”状态会解除所有其他的状态，如果给一个“战斗不能”的战斗者附加别的状态，不会成功），如果有则附加无效，然后是附加这个状态，并且产生一定的效果，然后对@state进行排序，排序的依据是状态的优先级，也就是下图：<br><img src="/posts/2347af05/3-2.png"></p><p>第二个方法是真正的增加状态方法，可以增加一组状态，并且有成功率判定的条件。先是判定是否防御了这个状态（如果角色穿上了相应装备就会进入这一过程），如果不能防御，看是否状态是“不能抵抗”，否则按照ABCDEF的有效度进行判定。A是1，B是2，等等（注意，F1中对此处的解释有误！）。因此，如果想改ABCDEF代表的成功率，就要改下面这一行：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rand(<span class="number">100</span>) &lt; [<span class="number">0</span>,<span class="number">100</span>,<span class="number">80</span>,<span class="number">60</span>,<span class="number">40</span>,<span class="number">20</span>,<span class="number">0</span>][<span class="variable language_">self</span>.state_ranks[j]]</span><br></pre></td></tr></table></figure><p>比方说把A改成90%就把数组第二个数100改成90，就这么简单。</p><p>接下来我们看Game_Battler的分割定义3，这个脚本整体说的是攻击效果的定义，包括技能能否使用的判断，技能效果，普通攻击效果，物品效果。因此，论坛上很多人问到，如何进行自定义攻击效果设置，其实改的都是这里。在这里我们举两个例子：</p><p><strong>例1：技能需要消耗一定的道具</strong></p><p>这个问题已经很老了，相信大家也知道怎么处理，不过还是提一下。Game_Battler分割定义3的第一个函数就是判断技能能否使用，里面列出了各种情况，我们只要增加我们自定义的判定模式即可。比方说1号技能要消耗3个2号道具，就在函数的第一行写下这一句话就可以：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> skill_id == <span class="number">1</span> <span class="keyword">and</span> <span class="variable">$game_party</span>.item_number(<span class="number">2</span>) &lt; <span class="number">3</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这样，1号技能就有了个特殊判断，当然，要在1号技能的公共事件上设置使用后消耗3个2号物品即可，这个相信大家都会做。</p><p><strong>例2：技能伤害加成</strong></p><p>这个就是修改skill_effect方法就可以了，注意它的两个参数分别是使用者和特技，进行相应调整就可以。比方说，如果角色持有含属性[火]的武器，释放含有属性[火]的技能，则获得20%的伤害加成，就可以写（假如火属性的ID为1）：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.is_a?(<span class="title class_">Game</span>_Actor) &amp;&amp; <span class="variable">$data_weapons</span>[<span class="variable language_">self</span>.weapon_id].element_set.<span class="keyword">include</span>?(<span class="number">1</span>) &amp;&amp; skill.element_set.<span class="keyword">include</span>?(<span class="number">1</span>)</span><br><span class="line">  <span class="variable language_">self</span>.damage += <span class="variable language_">self</span>.damage / <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的第一个条件self.is_a?(Game_Actor)不能省略，因为对于敌人类(Game_Enemy)来讲，是没有weapon_id这个属性的，会引发NoMethodError。这个is_a?是判断某个实例是否属于某个类的函数，对任意的实例都有效。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">class</span> B &lt; A</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">class</span> C &lt; A</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ryan = B.new</span><br><span class="line">ryan.is_a?(A) <span class="comment">#true 这里B类的实例当然属于A类</span></span><br><span class="line">ryan.is_a?(B) <span class="comment">#true</span></span><br><span class="line">ryan.is_a?(C) <span class="comment">#false ryan不是C类的实例</span></span><br></pre></td></tr></table></figure><p>这个语句希望大家能够熟练使用，很多判断没有这句话，似乎是很难完成的。后面的那些语法，参考F1就基本能够写出。</p><p>接下来我们介绍一下Game_Actor，作为角色的类，有它的特殊性。</p><p>我们看一下专属于Game_Actor类的变量。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">attr_reader</span>   <span class="symbol">:name</span>                     <span class="comment"># 名称</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:character_name</span>           <span class="comment"># 角色 文件名</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:character_hue</span>            <span class="comment"># 角色 色相</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:class_id</span>                 <span class="comment"># 职业 ID</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:weapon_id</span>                <span class="comment"># 武器 ID</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:armor1_id</span>                <span class="comment"># 盾 ID</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:armor2_id</span>                <span class="comment"># 头防具 ID</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:armor3_id</span>                <span class="comment"># 身体体防具 ID</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:armor4_id</span>                <span class="comment"># 装饰品 ID</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:level</span>                    <span class="comment"># 水平</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:exp</span>                      <span class="comment"># EXP</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:skills</span>                   <span class="comment"># 特技</span></span><br></pre></td></tr></table></figure><p>中间那个character_name和character_hue指的是角色行走图的文件名和色相，而不是战斗图的文件名和色相。在这里看出，默认系统里面，角色类才有装备，等级，经验的刻画。</p><p>我们再向下看，就会看到属于Game_Actor的各种方法。前面说到的base_maxhp也在其中。具体的我就不领着大家一个个说了，只举一个例子。</p><p><strong>例：简单的装备附带技能系统</strong></p><p>这又是一个热门话题，不过很多人都解决过它。实际上，如果我们学习了这里，我们也能比较轻松地解决它，下面请看。（以下提供的解决办法还有很大提升空间，但是这个办法是最容易想到的办法）<br>步骤1：明确我们要做什么，如果给角色装备相应的装备，就让它学习相应的技能，卸下装备就遗忘相应的技能。注意：装备中的技能最好不要交叉（即两种不同种类的装备含有相同的技能），这样能让我们的系统简单一些，而且装备技能不可从其他渠道学习（即只能通过换上这种装备才能使用）。<br>步骤2：先要设定装备和技能的对应关系，有点像新数据库的构造，我们可以采用Hash表的方式构造一个数据库中无法设定的新数据。考虑到这个数据在全局都可以使用，应该定义成全局变量，而且定义在最外面的结构里面就可以了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$equipment_skill_table</span> = &#123;&#125; <span class="comment">#在这里定义的是Hash表</span></span><br><span class="line"><span class="variable">$equipment_skill_table</span>[[<span class="number">0</span>,<span class="number">1</span>]] = [<span class="number">1</span>,<span class="number">2</span>] <span class="comment">#这里定义1号武器的附带技能为1号和2号技能</span></span><br><span class="line"><span class="comment"># 注意，Hash表的主键是一个二元数组，第一个量表示装备种类，第二个量表示装备的ID，这样定义具有和系统的一致性。</span></span><br></pre></td></tr></table></figure><p>步骤3：增加装备的同时增加技能。翻开Game_Actor，我们看到了下面的方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">equip</span>(<span class="params">equip_type, id</span>)</span><br><span class="line">    <span class="keyword">case</span> equip_type</span><br><span class="line">    <span class="keyword">when</span> <span class="number">0</span>  <span class="comment"># 武器</span></span><br><span class="line">      <span class="keyword">if</span> id == <span class="number">0</span> <span class="keyword">or</span> <span class="variable">$game_party</span>.weapon_number(id) &gt; <span class="number">0</span></span><br><span class="line">        <span class="variable">$game_party</span>.gain_weapon(<span class="variable">@weapon_id</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="variable">@weapon_id</span> = id</span><br><span class="line">        <span class="variable">$game_party</span>.lose_weapon(id, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">when</span> <span class="number">1</span>  <span class="comment"># 盾</span></span><br><span class="line">      <span class="keyword">if</span> id == <span class="number">0</span> <span class="keyword">or</span> <span class="variable">$game_party</span>.armor_number(id) &gt; <span class="number">0</span></span><br><span class="line">        update_auto_state(<span class="variable">$data_armors</span>[<span class="variable">@armor1_id</span>], <span class="variable">$data_armors</span>[id])</span><br><span class="line">        <span class="variable">$game_party</span>.gain_armor(<span class="variable">@armor1_id</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="variable">@armor1_id</span> = id</span><br><span class="line">        <span class="variable">$game_party</span>.lose_armor(id, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">when</span> <span class="number">2</span>  <span class="comment"># 头</span></span><br><span class="line">      <span class="keyword">if</span> id == <span class="number">0</span> <span class="keyword">or</span> <span class="variable">$game_party</span>.armor_number(id) &gt; <span class="number">0</span></span><br><span class="line">        update_auto_state(<span class="variable">$data_armors</span>[<span class="variable">@armor2_id</span>], <span class="variable">$data_armors</span>[id])</span><br><span class="line">        <span class="variable">$game_party</span>.gain_armor(<span class="variable">@armor2_id</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="variable">@armor2_id</span> = id</span><br><span class="line">        <span class="variable">$game_party</span>.lose_armor(id, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">when</span> <span class="number">3</span>  <span class="comment"># 身体</span></span><br><span class="line">      <span class="keyword">if</span> id == <span class="number">0</span> <span class="keyword">or</span> <span class="variable">$game_party</span>.armor_number(id) &gt; <span class="number">0</span></span><br><span class="line">        update_auto_state(<span class="variable">$data_armors</span>[<span class="variable">@armor3_id</span>], <span class="variable">$data_armors</span>[id])</span><br><span class="line">        <span class="variable">$game_party</span>.gain_armor(<span class="variable">@armor3_id</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="variable">@armor3_id</span> = id</span><br><span class="line">        <span class="variable">$game_party</span>.lose_armor(id, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">when</span> <span class="number">4</span>  <span class="comment"># 装饰品</span></span><br><span class="line">      <span class="keyword">if</span> id == <span class="number">0</span> <span class="keyword">or</span> <span class="variable">$game_party</span>.armor_number(id) &gt; <span class="number">0</span></span><br><span class="line">        update_auto_state(<span class="variable">$data_armors</span>[<span class="variable">@armor4_id</span>], <span class="variable">$data_armors</span>[id])</span><br><span class="line">        <span class="variable">$game_party</span>.gain_armor(<span class="variable">@armor4_id</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="variable">@armor4_id</span> = id</span><br><span class="line">        <span class="variable">$game_party</span>.lose_armor(id, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这样，以武器为例，我们在when 0这个结构层次上做如下改动：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> id == <span class="number">0</span> <span class="keyword">or</span> <span class="variable">$game_party</span>.weapon_number(id) &gt; <span class="number">0</span></span><br><span class="line">  <span class="variable">$game_party</span>.gain_weapon(<span class="variable">@weapon_id</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment"># 去掉被卸下装备的附带技能</span></span><br><span class="line"><span class="comment"># 对应技能设定的情况下</span></span><br><span class="line">  <span class="keyword">if</span> <span class="variable">$equipment_skill_table</span>.<span class="keyword">include</span>?([<span class="number">0</span>,<span class="variable">@weapon_id</span>])</span><br><span class="line"><span class="keyword">for</span> skill_id <span class="keyword">in</span> <span class="variable">$equipment_skill_table</span>[[<span class="number">0</span>,id]]</span><br><span class="line">      <span class="variable language_">self</span>.forget_skill(skill_id)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="variable">@weapon_id</span> = id</span><br><span class="line">  <span class="variable">$game_party</span>.lose_weapon(id, <span class="number">1</span>)</span><br><span class="line">  <span class="comment"># 增加新装备上的技能</span></span><br><span class="line">  <span class="comment"># 对应技能设定的情况下</span></span><br><span class="line">  <span class="keyword">if</span> <span class="variable">$equipment_skill_table</span>.<span class="keyword">include</span>?([<span class="number">0</span>,id])</span><br><span class="line"><span class="keyword">for</span> skill_id <span class="keyword">in</span> <span class="variable">$equipment_skill_table</span>[[<span class="number">0</span>,id]]</span><br><span class="line">  <span class="variable language_">self</span>.learn_skill(skill_id)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如法炮制剩下的几个when分支就OK了。</p><p>再次提醒一下，$equipment_skill_table一定要先定义再使用，定义位置随意，但是最好定义在最外部的层次上（class保留字的外面）。</p><p>关于Game_Enemy类的，没有什么多说的，但是我们也可以自定义一些内容。</p><p>例如：能力值破限。在数据库中无法设置敌人的力量（str）为999以上，但是在这里我们就可以做到。如果要设置1号敌人的力量为1500，则找到base_str那一个函数，改写成：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">base_str</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable">@enemy_id</span> == <span class="number">1</span> ? <span class="number">1500</span> <span class="symbol">:</span><span class="variable">$data_enemies</span>[<span class="variable">@enemy_id</span>].str</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>利用条件表达式就可以轻松完成。不过要定义多个敌人能力值破限，就要定义一个自定义的数据库，然后再进行函数值返回，这里就不说了。</p><p>我们向下看，可以知道，敌人的普通攻击是没有属性的，也没有附加状态的变化，用类似的方法，我们可以修改这部分的内容，这里就不说了。</p><p>在这里我们留下第一个作业题目。请设定一个被动技能，它的效果是，学习该技能的角色会降低所有状态（不能抵抗的除外）的命中可能性（默认是20%），即如果原来角色对状态1的有效度是C（60%命中），则学习该技能后降为D（40%）。</p><h3 id="3-1-2-角色队伍Game-Party"><a href="#3-1-2-角色队伍Game-Party" class="headerlink" title="3.1.2  角色队伍Game_Party"></a>3.1.2  角色队伍Game_Party</h3><p>这个也是我们经常修改的类别，下面是Game_Party的脚本开头。游戏里面Game_Party的实例是$game_party</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 定义实例变量</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:actors</span>                   <span class="comment"># 角色</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:gold</span>                     <span class="comment"># 金钱</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:steps</span>                    <span class="comment"># 步数</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># ● 初始化对像</span></span><br><span class="line">  <span class="comment">#--------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span></span><br><span class="line">    <span class="comment"># 建立角色序列</span></span><br><span class="line">    <span class="variable">@actors</span> = []</span><br><span class="line">    <span class="comment"># 初始化金钱与步数</span></span><br><span class="line">    [url=home.php?mod=space&amp;uid=<span class="number">236945</span>]<span class="variable">@gold</span>[<span class="regexp">/url] = 0</span></span><br><span class="line"><span class="regexp">    @steps = 0</span></span><br><span class="line"><span class="regexp">    # 生成物品、武器、防具的所持数 hash</span></span><br><span class="line"><span class="regexp">    @items = &#123;&#125;</span></span><br><span class="line"><span class="regexp">    @weapons = &#123;&#125;</span></span><br><span class="line"><span class="regexp">    @armors = &#123;&#125;</span></span><br><span class="line"><span class="regexp">  end</span></span><br></pre></td></tr></table></figure><p>我们注意到，角色，金钱，步数是整个队伍共有的东西。而我们看到，道具，武器，防具却没有用attr来定义属性，因为物品之类的东西，RGSS中设置了上限（默认99），如果直接用attr来定义，则还需要进行范围修正的处理。由于没有定义相应的方法，因此用$game_party.items[1]这样的方法取得1号物品的个数是不可以的。也无法通过$game_party.gold &#x3D; 100这样的语句修改金钱（因为gold属性只是attr_reader定义的，只能读取而不能写入）。</p><p>$game_party.actors指的是当前队伍中所有的队员，注意，$game_party.actors可以看作是$game_actors的一个子集，随着角色信息的变化，二者的数据时同步的。由于系统限制，默认$game_party.actors中最大人数为4，如果要做一个队伍脚本的话，首先就要突破这个限制。</p><p>我们向后看，定义的方法包括角色的添加和删除，各种队伍物品的添加和删除，最后还有确定角色目标的方法，这个都不难理解，需要的时候，甚至都可以翻过来参考，不过我还是建议大家把这些方法熟练记住。<br>       例如，现在要清除队伍中所有的物品。如果要是不知道脚本的话，那就麻烦大了，用事件的话是会累死人的。但是知道了队伍脚本，就不一样了，于是我们可以写：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clear_items</span></span><br><span class="line">  <span class="variable">@items</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>把这个方法定义在Game_Party的内部，然后在事件中插入脚本$game_party.clear_items即可。</p><p>注意@items没有被外部化，因此用$game_party.items[id] &#x3D; 0这样的语句是不可以的，重申！</p><p>大家可能看到Game_Party里面的方法简单易懂，因此涉及到物品，金钱等变量时，一定要参考Game_Party。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_actor</span>(<span class="params">actor_id</span>)</span><br><span class="line">    <span class="comment"># 获取角色</span></span><br><span class="line">    actor = <span class="variable">$game_actors</span>[actor_id]</span><br><span class="line">    <span class="comment"># 同伴人数未满 4 人、本角色不在队伍中的情况下</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@actors</span>.size &lt; <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="variable">@actors</span>.<span class="keyword">include</span>?(actor)</span><br><span class="line">      <span class="comment"># 添加角色</span></span><br><span class="line">      <span class="variable">@actors</span>.push(actor)</span><br><span class="line">      <span class="comment"># 还原主角</span></span><br><span class="line">      <span class="variable">$game_player</span>.refresh</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面的脚本说明，$game_party.actors中最多只能容纳4个成员，如果队伍人数已满，再添加角色是无效的，有很多人认为用事件的“添加队员”指令，就一定会成功，其实不然。如果想让队伍中的人数突破限制的话，就必须首先在这里做文章。当然改成5人战斗脚本光改这里肯定是不够的，我们必须要进行大量的整合，这里就不细说了。</p><h3 id="3-1-3-地图角色Game-Character及它的两个子类Game-Player（角色）和Game-Event（事件）-size"><a href="#3-1-3-地图角色Game-Character及它的两个子类Game-Player（角色）和Game-Event（事件）-size" class="headerlink" title="3.1.3  地图角色Game_Character及它的两个子类Game_Player（角色）和Game_Event（事件）[&#x2F;size]"></a>3.1.3  地图角色Game_Character及它的两个子类Game_Player（角色）和Game_Event（事件）[&#x2F;size]</h3><p>这些脚本都是处理地图画面上角色以及NPC移动的类，我们先从Game_Character看起。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">attr_reader</span>   <span class="symbol">:id</span>                       <span class="comment"># ID</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:x</span>                        <span class="comment"># 地图 X 坐标 (理论坐标)</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:y</span>                        <span class="comment"># 地图 Y 坐标 (理论坐标)</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:real_x</span>                   <span class="comment"># 地图 X 坐标 (实际坐标 * 128)</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:real_y</span>                   <span class="comment"># 地图 Y 坐标 (实际坐标 * 128)</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:tile_id</span>                  <span class="comment"># 元件 ID  (0 为无效)</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:character_name</span>           <span class="comment"># 角色 文件名</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:character_hue</span>            <span class="comment"># 角色 色相</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:opacity</span>                  <span class="comment"># 不透明度</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:blend_type</span>               <span class="comment"># 合成方式</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:direction</span>                <span class="comment"># 朝向</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:pattern</span>                  <span class="comment"># 图案</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:move_route_forcing</span>       <span class="comment"># 移动路线强制标志</span></span><br><span class="line">  <span class="built_in">attr_reader</span>   <span class="symbol">:through</span>                  <span class="comment"># 穿透</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:animation_id</span>             <span class="comment"># 动画 ID</span></span><br><span class="line">  <span class="built_in">attr_accessor</span> <span class="symbol">:transparent</span>              <span class="comment"># 透明状态</span></span><br></pre></td></tr></table></figure><p>在这里我们看到了Game_Character的一些属性，这里的x和y相当于我们地图编辑器中的这个：<br>![]{3-3.png}<br>是理论的坐标值，实际坐标值和理论坐标值有个换算关系，实际坐标 &#x3D; 理论坐标 * 128，这个记住就好。我们写脚本的时候，理论坐标用得最多。Character_name和character_hue表示的是角色行走图的文件名和色相，这个和我们刚才讲Game_Actor里面的属性几乎是一样的，不过Game_Character作为角色行走图类，这个属性和Game_Actor的还是有本质区别。</p><p>pattern指的是角色行走图的图案序号，这是个什么东西呢？我们知道角色走动的时候，会有踏步动画，一个角色行走图文件是4*4个图形，不同横行代表不同方向，同一横行的四个图案就是用来做成动画的，这个pattern就是指同一横行的图形号码。</p><p>direction指的是行走图的朝向，在RGSS中，数字2、4、6、8分别代表下，左，右，上。这个怎么记忆呢？我们看看电脑上的数字小键盘，这个对应关系，正好是小键盘数字和方向的对应。</p><p>接下来我们看下这里面的各种方法。RGSS有一套默认的角色移动规则，这类规则我们也不用做太多改变，已经是比较合理的了。因此下面的函数我们看看形式即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">screen_z</span>(<span class="params">height = <span class="number">0</span></span>)</span><br><span class="line">    <span class="comment"># 在最前显示的标志为 ON 的情况下</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@always_on_top</span></span><br><span class="line">      <span class="comment"># 无条件设置为 999</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">999</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 通过实际坐标和地图的显示位置来求得画面坐标</span></span><br><span class="line">    z = (<span class="variable">@real_y</span> - <span class="variable">$game_map</span>.display_y + <span class="number">3</span>) / <span class="number">4</span> + <span class="number">32</span></span><br><span class="line">    <span class="comment"># 元件的情况下</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@tile_id</span> &gt; <span class="number">0</span></span><br><span class="line">      <span class="comment"># 元件的优先不足 * 32 </span></span><br><span class="line">      <span class="keyword">return</span> z + <span class="variable">$game_map</span>.priorities[<span class="variable">@tile_id</span>] * <span class="number">32</span></span><br><span class="line">    <span class="comment"># 角色的场合</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># 如果高度超过 32 就判定为满足 31</span></span><br><span class="line">      <span class="keyword">return</span> z + ((height &gt; <span class="number">32</span>) ? <span class="number">31</span> : <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>例如，我们看一下这个画面z坐标的方法。因为我们是调查的行走图在画面上的z坐标，而不是元件，因此我们不要随便引入优先级这个概念。首先，我们知道，事件选项里面有一个“总在最前面显示”，这种事件的z坐标是最高的。另外，我们要注意，表示角色的Game_Player是没有这个属性的，因此角色永远也不能成为画面最上层的东西。下面我们来看其他情况的z坐标。这里先计算了一下画面的y坐标，这是为什么呢？因为我们知道表示角色和事件的图形都有一定的高度，而在地图上，一个格子的大小是32<em>32，超出的部分就要向上下左右扩张，而我们知道，一个NPC图形的大小是32</em>48，RGSS中，默认把图形的中下方的32*32区域放在指定坐标的格子中，因此角色头部就会覆盖他上方的格子。</p><p><img src="/posts/2347af05/3-4.png"><br>比方说上图这种情况，我们要让y坐标大的角色z坐标也稍微大一点，这样可以覆盖他上方的角色图形。当然我们知道，角色图形可以是元件，那么元件的z坐标就和它的优先度有关。在最后一行我们可以看到，1个优先度&#x3D;32个z坐标，也就是说，角色和事件图形的优先度是大于0小于1的，因此只要优先度超过1的元件，都会把事件盖住。</p><p>Game_Character下面两页几乎都是写移动和跳跃规则的方法。因此，我们除了在事件中运用“设置移动路线”来让角色移动外，还可以直接用脚本来让角色运动。例如写$game_player.move_left就可以让主角左移动一格。</p><p>然后我们看Game_Player。</p><p>因为在主角移动时，画面会始终跟随主角移动，因此Game_Player里面多了个center(x,y)方法。这个大家看看就行了，没必要完全搞懂。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increase_steps</span></span><br><span class="line">    <span class="variable language_">super</span></span><br><span class="line">    <span class="comment"># 不是强制移动路线的场合</span></span><br><span class="line">    <span class="keyword">unless</span> <span class="variable">@move_route_forcing</span></span><br><span class="line">      <span class="comment"># 增加步数</span></span><br><span class="line">      <span class="variable">$game_party</span>.increase_steps</span><br><span class="line">      <span class="comment"># 步数是偶数的情况下</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">$game_party</span>.steps % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">        <span class="comment"># 检查连续伤害</span></span><br><span class="line">        <span class="variable">$game_party</span>.check_map_slip_damage</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这个方法中，我们终于知道了游戏为什么要记录主角的步数。很多人认为新工程里面主菜单显示“步数”完全是个多余之举，确实我也认为没有显示的必要。步数是用来生成遇敌计数和检查连续伤害用的，这里，地图用的连续伤害是每走2步就减去1%的HP，当然你可以对此进行更改。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">refresh</span></span><br><span class="line">    <span class="comment"># 同伴人数为 0 的情况下</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$game_party</span>.actors.size == <span class="number">0</span></span><br><span class="line">      <span class="comment"># 清除角色的文件名及对像</span></span><br><span class="line">      <span class="variable">@character_name</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="variable">@character_hue</span> = <span class="number">0</span></span><br><span class="line">      <span class="comment"># 分支结束</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 获取带头的角色</span></span><br><span class="line">    actor = <span class="variable">$game_party</span>.actors[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 设置角色的文件名及对像</span></span><br><span class="line">    <span class="variable">@character_name</span> = actor.character_name</span><br><span class="line">    <span class="variable">@character_hue</span> = actor.character_hue</span><br><span class="line">    <span class="comment"># 初始化不透明度和合成方式子</span></span><br><span class="line">    <span class="variable">@opacity</span> = <span class="number">255</span></span><br><span class="line">    <span class="variable">@blend_type</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这里我们明白了，地图上角色的图形和队伍中第一名角色的图形是一致的。因此，我们完全可以把它改成别的。在Game_Party中我们可以增加“领队”这一属性，然后把中间的actor &#x3D; $game_party.actors[0]换成actor &#x3D; $game_party.leader即可。当然Game_Party的leader还需要定义。另外，我们经常遇到主角变更交通工具的情况，比方说航海的时候，主角图形则要显示为一艘船。这个我们纯用事件是无法做到的（我们可以通过改变队伍中第一个角色的行走图来获得这个效果，但是你打开菜单，会发现角色的脸谱也变成了一艘船，这个显然很不合理），我们仍然可以在这里进行改动。例如，设置一个航海中的标志，如果队伍在航海中，则直接设置@character_name和@character_hue即可。</p><p>在Game_Player的update方法中，我们看到了输入的处理。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title class_">Input</span>.dir4</span><br><span class="line"><span class="keyword">when</span> <span class="number">2</span></span><br><span class="line">  move_down</span><br><span class="line"><span class="keyword">when</span> <span class="number">4</span></span><br><span class="line">  move_left</span><br><span class="line"><span class="keyword">when</span> <span class="number">6</span></span><br><span class="line">  move_right</span><br><span class="line"><span class="keyword">when</span> <span class="number">8</span></span><br><span class="line">  move_up</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这是对4方向输入的处理，用Input.dir4，游戏中还有一个对8方向的输入处理Input.dir8，增加了4个斜向的移动，1、3、7、9分别表示，左下，右下，左上，右上，还是跟小键盘的方位是一样的（注：F1再次出现错误，F1原来写的是数字1到8表示8方向输入，这是不对的，应该是1、2、3、4、6、7、8、9才对）。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title class_">Input</span>.dir8</span><br><span class="line"><span class="keyword">when</span> <span class="number">1</span></span><br><span class="line">  move_lower_left</span><br><span class="line"><span class="keyword">when</span> <span class="number">2</span></span><br><span class="line">  move_down</span><br><span class="line"><span class="keyword">when</span> <span class="number">3</span></span><br><span class="line">  move_lower_right</span><br><span class="line"><span class="keyword">when</span> <span class="number">4</span></span><br><span class="line">  move_left</span><br><span class="line"><span class="keyword">when</span> <span class="number">9</span></span><br><span class="line">  move_upper_right</span><br><span class="line"><span class="keyword">when</span> <span class="number">6</span></span><br><span class="line">  move_right</span><br><span class="line"><span class="keyword">when</span> <span class="number">7</span></span><br><span class="line">  move_upper_left</span><br><span class="line"><span class="keyword">when</span> <span class="number">8</span></span><br><span class="line">  move_up</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个是修改后8方向是输入，大家可以试一下。</p><p>关于Game_Xxxx类脚本我们就要说这些，大家有兴趣的话可以多看看脚本，会有更多意想不到的发现。</p><h2 id="3-2-自制游戏对象"><a href="#3-2-自制游戏对象" class="headerlink" title="3.2  自制游戏对象"></a>3.2  自制游戏对象</h2><p>看了这么多游戏对象的脚本，是不是有自制游戏对象的念头了呢？那我们在这一小节就说说如何自制属于你自己的游戏对象脚本。</p><h3 id="3-2-1-起步"><a href="#3-2-1-起步" class="headerlink" title="3.2.1  起步"></a>3.2.1  起步</h3><p>首先要明白，你自己想自定义的游戏数据到底属不属于游戏对象，如果不属于（比方说你要建立一个数据库的类，这就不属于游戏对象），那么就不应该用游戏对象的思路。总的来说，随着游戏进行，随时都有改变可能，并且跟玩家进行直接互动的对象，大多都是游戏对象。下面我们来看一个例子：</p><p>例如，制作一个真实商店，要求是商店尽可能还原真实生活中的商店，有库存限制，你卖给这个商店的物品，商店也会原封不动显示出来。这就是一个游戏对象。</p><h3 id="3-2-2-分析属性和方法"><a href="#3-2-2-分析属性和方法" class="headerlink" title="3.2.2  分析属性和方法"></a>3.2.2  分析属性和方法</h3><p>下面我们要分析一下，我们建立的游戏对象应该有哪些内容和方法。</p><p>还是以真实商店为例。</p><p>我们需要的是商店的最大库存（所有商品的最大数量，为了方便起见，对于同一个商店，所有商品的最大库存都是一样的），以及商店里面各种商品的数量。除此以外，暂时还未想到其他的属性。</p><p>真实商店的方法很简单，就是出货和进货，不过考虑到物品分为道具，武器，防具3种，我们可能要定义很多方法。</p><p>暂时想到这么多，然后我们就可以开工了。</p><h3 id="3-2-3-写出游戏对象脚本"><a href="#3-2-3-写出游戏对象脚本" class="headerlink" title="3.2.3  写出游戏对象脚本"></a>3.2.3  写出游戏对象脚本</h3><p>我们现在，就可以根据我们的分析，来写出真实商店脚本的游戏对象部分了。先是定义各种属性，考虑到道具，武器，防具的不同性质，我们把它们定义在三个表中。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>_VisualShop</span><br><span class="line">  <span class="built_in">attr_reader</span> <span class="symbol">:max_number</span></span><br><span class="line">  <span class="built_in">attr_reader</span> <span class="symbol">:shop_goods_item</span></span><br><span class="line">  <span class="built_in">attr_reader</span> <span class="symbol">:shop_goods_weapon</span></span><br><span class="line">  <span class="built_in">attr_reader</span> <span class="symbol">:shop_goods_armor</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接下来定义初始化：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">max_number,items,weapons,armors</span>)</span><br><span class="line">  <span class="variable">@max_number</span> = max_number</span><br><span class="line">  <span class="variable">@shop_goods_item</span> = &#123;&#125;</span><br><span class="line">  <span class="variable">@shop_goods_weapon</span> = &#123;&#125;</span><br><span class="line">  <span class="variable">@shop_goods_armor</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> items</span><br><span class="line">    <span class="variable">@shop_goods_item</span>[j] = <span class="variable">@max_number</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> weapons</span><br><span class="line">    <span class="variable">@shop_goods_weapon</span>[j] = <span class="variable">@max_number</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> armors</span><br><span class="line">    <span class="variable">@shop_goods_armor</span>[j] = <span class="variable">@max_number</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个初始化就完成了，我们注意，传进去的参数有4个，分别是库存最大数量，各种物品的数组，数组里面是物品的ID，我们这里用ID而不是用物品的实例，是为了模仿游戏主角背包的存储模式，这个一定要注意。然后就是把商店各种物品数量初始化为库存最大值。这个也是看个人需要。我们用的是Hash表来表示现有的库存，这个也是借鉴了Game_Party中对于队伍中各种物品武器防具的刻画。写到这里，我们可以考虑给真实商店增加一个变量，表示商店中可以显示库存为0的物品（其余的库存为0的物品就直接不显示）。这是因为你卖给这个商店的物品和这个商店原有的物品本质是不一样的。这是一个二维数组，含有3个一维数组，分别表示总显示的道具、武器、防具。因此在initialize的最后，加入</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@always_shown</span> = []</span><br><span class="line"><span class="variable">@always_shown</span>[<span class="number">0</span>] = <span class="variable">@shop_goods_item</span>.keys</span><br><span class="line"><span class="variable">@always_shown</span>[<span class="number">1</span>] = <span class="variable">@shop_goods_weapon</span>.keys</span><br><span class="line"><span class="variable">@always_shown</span>[<span class="number">2</span>] = <span class="variable">@shop_goods_armor</span>.keys</span><br></pre></td></tr></table></figure><p>这个显然我们不用把它公开化，放在这里就可以了。</p><p>然后是各种方法，也是非常简单的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">import</span>(<span class="params">type,id,number</span>)</span><br><span class="line">  <span class="keyword">case</span> type</span><br><span class="line">  <span class="keyword">when</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@shop_goods_item</span>[id] == <span class="literal">nil</span></span><br><span class="line">      <span class="variable">@shop_goods_item</span>[id] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="variable">@shop_goods_item</span>[id] += number</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@shop_goods_item</span>[id] &gt; <span class="variable">@max_number</span></span><br><span class="line">      <span class="variable">@shop_goods_item</span>[id] = <span class="variable">@max_number</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">@shop_goods_item</span>[id] &lt;= <span class="number">0</span></span><br><span class="line">      <span class="variable">@shop_goods_item</span>[id] = <span class="number">0</span></span><br><span class="line">      <span class="keyword">unless</span> <span class="variable">@always_shown</span>[<span class="number">0</span>].<span class="keyword">include</span>?(id)</span><br><span class="line">        <span class="variable">@shop_goods_item</span>.delete(id)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">when</span> <span class="number">1</span></span><br><span class="line">    …..</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这是一个通用的商店进货的方法，type表示种类，0为道具，1为武器，2为防具。id是对应类型的id，number是数量。添加的时候，考虑到某物品的Hash个数可能不存在，因此要进行一步判断。然后再进行增加操作，并修改范围。如果最终个数是0并且不是永远显示的话，直接从相应Hash表中删除。这里只给出了道具部分的定义，武器和防具部分定义是类似的。</p><p>有了这个东西，出货的方法就很容易写了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">export</span>(<span class="params">type,id,number</span>)</span><br><span class="line">  import(type,id,-number)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>直接调用import方法，并将number取成负值即可。</p><p>到这里我们所有的基本方法就定义完了，Game_VisualShop也告一段落，不过，现在它只是一个游戏对象，如何将它和玩家互动起来，我们还需要学习后面的内容。</p><p>第3章的讲解就到这里，在下一章我们会将到窗口的使用，大家敬请期待吧。</p><h1 id="第4章节：窗口的使用"><a href="#第4章节：窗口的使用" class="headerlink" title="第4章节：窗口的使用"></a>第4章节：窗口的使用</h1><h1 id="第5章节：场景的使用（一）"><a href="#第5章节：场景的使用（一）" class="headerlink" title="第5章节：场景的使用（一）"></a>第5章节：场景的使用（一）</h1><h1 id="第6章节：场景的使用（二）"><a href="#第6章节：场景的使用（二）" class="headerlink" title="第6章节：场景的使用（二）"></a>第6章节：场景的使用（二）</h1><h1 id="第7章节：尾声"><a href="#第7章节：尾声" class="headerlink" title="第7章节：尾声"></a>第7章节：尾声</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h1 id=&quot;57自己想</summary>
      
    
    
    
    <category term="游戏开发" scheme="http://azkoree.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="rmxp脚本教程" scheme="http://azkoree.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/rmxp%E8%84%9A%E6%9C%AC%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="rmxp" scheme="http://azkoree.github.io/tags/rmxp/"/>
    
    <category term="游戏开发" scheme="http://azkoree.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="学习" scheme="http://azkoree.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="转载文章" scheme="http://azkoree.github.io/tags/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>RMXP脚本教程1 - 图片标题</title>
    <link href="http://azkoree.github.io/posts/7552dc29/"/>
    <id>http://azkoree.github.io/posts/7552dc29/</id>
    <published>2025-12-05T10:24:15.000Z</published>
    <updated>2025-12-21T14:46:14.668Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是我看<a href="https://www.bilibili.com/video/BV1Es411S7my/?p=4&share_source=copy_web&vd_source=7456c30741184bc32056a597f75c8c84">RyanBern的rmxp脚本教程</a>做的笔记，发在这只是用来督促自己。因为我自己是零基础，所以有些用词不够专业，记的也有些乱七八糟，请各位高抬贵手<br>如果要学的话，建议还是自己去看大大的视频教程</p><p>[toc]</p><h1 id="显示标题图片"><a href="#显示标题图片" class="headerlink" title="显示标题图片"></a>显示标题图片</h1><h2 id="生成和释放图片"><a href="#生成和释放图片" class="headerlink" title="生成和释放图片"></a>生成和释放图片</h2><p>scene_title类处理标题画面<br>在“生成标题图形”处生成标题的文字图片，使用显示图片的命令<br>25行后：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示标题文字图片</span></span><br><span class="line"><span class="variable">@sprite1</span> = <span class="title class_">Sprite</span>.new <span class="comment">#新建一个Sprite</span></span><br><span class="line"><span class="variable">@sprite1</span>.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(<span class="string">&quot;Title-Words.png&quot;</span>) <span class="comment">#载入这张图片</span></span><br><span class="line"><span class="variable">@sprite2</span> = <span class="title class_">Sprite</span>.new</span><br><span class="line"><span class="variable">@sprite2</span>.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(<span class="string">&quot;Title-Subwords.png&quot;</span>)</span><br></pre></td></tr></table></figure><p>sprite是用于显示图片的类</p><p>在使用图片过后，需要进行释放<br>90行后：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@sprite1</span>.bitmap.dispose <span class="comment"># 释放位图</span></span><br><span class="line"><span class="variable">@sprite1</span>.dispose <span class="comment">#释放精灵本身</span></span><br><span class="line"><span class="variable">@sprite2</span>.bitmap.dispose</span><br><span class="line"><span class="variable">@sprite2</span>.dispose</span><br></pre></td></tr></table></figure><p>注意顺序是先释放位图再释放精灵</p><h2 id="调整图片位置"><a href="#调整图片位置" class="headerlink" title="调整图片位置"></a>调整图片位置</h2><p>使用sprite类的属性</p><blockquote><p>x<br>精灵的 X 座标。<br>y<br>精灵的 Y 座标。<br>z<br>精灵的 Z 座标。该值大的东西显示在上面。Z 座标相同的话，则后生成的对象显示在上面。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示标题文字图片</span></span><br><span class="line"><span class="variable">@sprite1</span> = <span class="title class_">Sprite</span>.new <span class="comment"># 新建一个Sprite</span></span><br><span class="line"><span class="variable">@sprite1</span>.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(<span class="string">&quot;Title-Words.png&quot;</span>) <span class="comment"># 载入这张图片</span></span><br><span class="line"><span class="variable">@sprite1</span>.x = <span class="number">112</span></span><br><span class="line"><span class="variable">@sprite1</span>.y = <span class="number">32</span> <span class="comment">#设定图片的位置</span></span><br><span class="line"><span class="variable">@sprite2</span> = <span class="title class_">Sprite</span>.new</span><br><span class="line"><span class="variable">@sprite2</span>.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(<span class="string">&quot;Title-Subwords.png&quot;</span>)</span><br><span class="line"><span class="variable">@sprite2</span>.x = <span class="number">128</span></span><br><span class="line"><span class="variable">@sprite2</span>.y = <span class="number">96</span></span><br></pre></td></tr></table></figure><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><p>制作两个标题从左右分别滑入，从完全透明到不透明，在屏幕中间重合为一个的效果<br>首先添加另一个标题图片的精灵</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@sprite3</span> = <span class="title class_">Sprite</span>.new</span><br><span class="line"><span class="variable">@sprite3</span>.bitmap = <span class="variable">@sprite1</span>.bitmap <span class="comment">#图片和sprite1相同，因此直接引用sprite1的图片</span></span><br><span class="line"><span class="variable">@sprite3</span>.x = <span class="number">240</span></span><br><span class="line"><span class="variable">@sprite3</span>.y = <span class="number">32</span></span><br><span class="line"><span class="variable">@sprite4</span> = sprite.new</span><br><span class="line"><span class="variable">@@sprite4</span>.bitmap = <span class="variable">@sprite2</span>.bitmap</span><br><span class="line"><span class="variable">@sprite4</span>.x = <span class="number">256</span></span><br><span class="line"><span class="variable">@sprite4</span>.y = <span class="number">96</span></span><br></pre></td></tr></table></figure><p>进行释放</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@sprite3</span>.dispose</span><br><span class="line"><span class="variable">@sprite4</span>.dispose <span class="comment">#sprite1的图片已经释放，再次释放会出错</span></span><br></pre></td></tr></table></figure><p>要实现画面的动态效果，需要进行过渡，来解除画面的冻结<br>82行后：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行过渡</span></span><br><span class="line"><span class="title class_">Graphic</span>.transition</span><br><span class="line"><span class="comment"># 标题过渡</span></span><br><span class="line">title_fade_in </span><br></pre></td></tr></table></figure><p>在位图新建位置设置初始不透明度</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@sprite1</span>.opacity = <span class="number">0</span></span><br><span class="line"><span class="variable">@sprite2</span>.opacity = <span class="number">0</span></span><br><span class="line"><span class="variable">@sprite3</span>.opacity = <span class="number">0</span></span><br><span class="line"><span class="variable">@sprite4</span>.opacity = <span class="number">0</span> <span class="comment"># 设置初始透明度为0</span></span><br></pre></td></tr></table></figure><p>然后对title_fade_in方法进行定义</p><p>过渡有16帧，因此标题过渡的过程要循环执行16次<br>两个图片之间相差128，执行16次，每次移动4个像素，透明度提高16</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">title_fade_in</span></span><br><span class="line">    <span class="number">16</span>.times <span class="keyword">do</span> <span class="comment"># 16次循环</span></span><br><span class="line">        <span class="variable">@sprite1</span>.x += <span class="number">4</span></span><br><span class="line">        <span class="variable">@sprite2</span>.x += <span class="number">4</span></span><br><span class="line">        <span class="variable">@sprite3</span>.x -= <span class="number">4</span></span><br><span class="line">        <span class="variable">@sprite4</span>.x -= <span class="number">4</span></span><br><span class="line">        <span class="variable">@sprite1</span>.opacity += <span class="number">16</span></span><br><span class="line">        <span class="variable">@sprite2</span>.opacity += <span class="number">16</span></span><br><span class="line">        <span class="variable">@sprite3</span>.opacity += <span class="number">16</span></span><br><span class="line">        <span class="variable">@sprite4</span>.opacity += <span class="number">16</span></span><br><span class="line">        <span class="title class_">Graphic</span>.update <span class="comment"># 屏幕刷新</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="图片选项"><a href="#图片选项" class="headerlink" title="图片选项"></a>图片选项</h1><h2 id="载入图片"><a href="#载入图片" class="headerlink" title="载入图片"></a>载入图片</h2><p>用数组的方式来载入图片，避免啰嗦</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@sprite_commands</span> = [] <span class="comment"># 建立数组</span></span><br><span class="line">(<span class="number">0</span>..<span class="number">2</span>).each <span class="keyword">do</span> |<span class="params">i</span>| <span class="comment"># 迭代，依次传入参数i</span></span><br><span class="line">    sprite = <span class="title class_">Sprite</span>.new</span><br><span class="line">    sprite.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(<span class="string">&quot;menu-<span class="subst">#&#123;i&#125;</span>-off.png&quot;</span>) <span class="comment">#内嵌表达式</span></span><br><span class="line">    sprite.x = <span class="number">420</span></span><br><span class="line">    sprite.y = <span class="number">320</span> + <span class="number">32</span> * i</span><br><span class="line">    <span class="variable">@sprite_commands</span> &lt;&lt; sprite <span class="comment"># 生成的sprite依次加入到建立的数组中</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>进行释放</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 释放图片命令</span></span><br><span class="line"><span class="variable">@sprite_commands</span>.each <span class="keyword">do</span> |<span class="params">sprite</span>|</span><br><span class="line">    sprite.bitmap.dispose</span><br><span class="line">    sprite.dispose</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="图片选项的处理"><a href="#图片选项的处理" class="headerlink" title="图片选项的处理"></a>图片选项的处理</h2><p>删除涉及到command_window的部分，包括命令窗口的生成，对“继续”是否为灰色的判断，释放命令窗口，刷新命令窗口，光标分支<br>在生成图片命令后，新建一个变量，用于表示光标位置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Index</span> = <span class="number">0</span> <span class="comment">#表示光标的第一个位置</span></span><br></pre></td></tr></table></figure><p>同时将139行对光标位置的判断变量改为index</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> @index</span><br></pre></td></tr></table></figure><p>在光标位置改变时，图片选项也要变化<br>定义一个新的方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Index=</span>(<span class="params">index</span>) <span class="comment"># 括号内的index为参数，括号外的为方法名</span></span><br><span class="line">    <span class="keyword">if</span> index &gt; <span class="number">2</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span></span><br><span class="line">        index = <span class="number">2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    sprite = <span class="variable">@sprite_commands</span>[<span class="variable">@index</span>] <span class="comment"># 简单来说，<span class="doctag">@index</span>是光标位置改变之前，index是改变之后，这里读取改变之前的精灵</span></span><br><span class="line">    sprite.bitmap.dispose <span class="comment"># 释放原来的图片</span></span><br><span class="line">    sprite.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(<span class="string">&quot;menu-<span class="subst">#&#123;<span class="variable">@index</span>&#125;</span>-off.png&quot;</span>) <span class="comment"># 光标位置改变后，原先的选项图片会变成关闭的状态</span></span><br><span class="line">     sprite_new = <span class="variable">@sprite_commands</span>[index] <span class="comment"># 建立一个光标改变后的sprite</span></span><br><span class="line">    sprite.bitmap.dispose <span class="comment"># 释放原来的图片</span></span><br><span class="line">    sprite_new.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(<span class="string">&quot;menu-<span class="subst">#&#123;<span class="variable">@index</span>&#125;</span>-on.png&quot;</span>) <span class="comment"># 光标位置改变后，对应的选项图片变为打开的状态</span></span><br><span class="line">    <span class="variable">@index</span> = index <span class="comment"># <span class="doctag">@index</span>变为了新的，用于下一次光标位置的改变</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>定义方法后，在生成图片选项的位置进行调用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@sprite_commands</span> = [] <span class="comment"># 建立数组</span></span><br><span class="line">(<span class="number">0</span>..<span class="number">2</span>).each <span class="keyword">do</span> |<span class="params">i</span>| <span class="comment"># 迭代，依次传入参数i</span></span><br><span class="line">    sprite = <span class="title class_">Sprite</span>.new</span><br><span class="line">    sprite.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(<span class="string">&quot;menu-<span class="subst">#&#123;i&#125;</span>-off.png&quot;</span>) <span class="comment">#内嵌表达式</span></span><br><span class="line">    sprite.x = <span class="number">420</span></span><br><span class="line">    sprite.y = <span class="number">320</span> + <span class="number">32</span> * i</span><br><span class="line">    <span class="variable">@sprite_commands</span> &lt;&lt; sprite <span class="comment"># 生成的sprite依次加入到建立的数组中</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="variable">@index</span> = <span class="number">0</span> <span class="comment">#初始化实例变量</span></span><br><span class="line"><span class="variable language_">self</span>.index = <span class="number">0</span> <span class="comment"># 调用index方法，参数为0，因为在类的内部调用方法，因此对象为self</span></span><br></pre></td></tr></table></figure><p>游戏测试，光标无法移动</p><h2 id="图片选项移动的效果"><a href="#图片选项移动的效果" class="headerlink" title="图片选项移动的效果"></a>图片选项移动的效果</h2><p>在update下调用一个用于图片选项刷新的方法，然后进行定义</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span></span><br><span class="line">    update_command</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_command</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title class_">Input</span> trigger?(<span class="title class_">Input</span><span class="symbol">:</span><span class="symbol">:DOWN</span>) <span class="comment">#判断是否按下了下方向键</span></span><br><span class="line">        <span class="variable">$game_system</span>.se_play(<span class="variable">$data_system</span>.cursor_se)</span><br><span class="line">        <span class="variable language_">self</span>.index = <span class="variable">@Index</span> +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment">#防止处理出错</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title class_">Input</span>.trigger?(<span class="title class_">Input</span><span class="symbol">:</span><span class="symbol">:UP</span>)</span><br><span class="line">        <span class="variable language_">self</span>.index = <span class="variable">@index</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="判定继续的有效性"><a href="#判定继续的有效性" class="headerlink" title="判定继续的有效性"></a>判定继续的有效性</h2><p>在有存档的情况下，“继续”选项可以选择，反之则为灰色的无效状态</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无效的情况下，继续的颜色显示为灰色</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">@continue_enabled</span></span><br><span class="line">    <span class="variable language_">self</span>.index = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable">@sprite_command</span>[<span class="number">1</span>].bitmap.dispose</span><br><span class="line">    <span class="variable">@sprite</span>.command[<span class="number">1</span>].bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(<span class="string">&quot;menu-5-off.png&quot;</span>) <span class="comment">#如果继续无效，就释放正常情况下的图片，改为无效状态的图片</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对@index部分也要改</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Index=</span>(<span class="params">index</span>) </span><br><span class="line">    <span class="keyword">if</span> index &gt; <span class="number">2</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span></span><br><span class="line">        index = <span class="number">2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    sprite = <span class="variable">@sprite_commands</span>[<span class="variable">@index</span>] </span><br><span class="line">    sprite.bitmap.dispose </span><br><span class="line">    filename = !<span class="variable">@continue_enabled</span> &amp;&amp; <span class="variable">@index</span> == <span class="number">1</span> ? <span class="string">&quot;menu-5-off.png&quot;</span> : <span class="string">&quot;menu-<span class="subst">#&#123;<span class="variable">@index</span>&#125;</span>-off.png&quot;</span> <span class="comment">#逻辑判断，若？前的表达式为真，则计算：前的表达式</span></span><br><span class="line">    sprite.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(filename) </span><br><span class="line">     sprite_new = <span class="variable">@sprite_commands</span>[index] </span><br><span class="line">    sprite_new.bitmap.dispose </span><br><span class="line">    filename_new = !<span class="variable">@continue_enabled</span> &amp;&amp; index == <span class="number">1</span> ? <span class="string">&quot;menu-5-off.png&quot;</span> : <span class="string">&quot;menu-<span class="subst">#&#123;index&#125;</span>-off.png&quot;</span><span class="comment">#同上</span></span><br><span class="line">    sprite_new.bitmap = <span class="variable constant_">RPG</span><span class="symbol">:</span><span class="symbol">:Cache</span>.title(<span class="string">&quot;filename.new&quot;</span>) </span><br><span class="line">    <span class="variable">@index</span> = index </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="游戏开发" scheme="http://azkoree.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="rmxp脚本教程" scheme="http://azkoree.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/rmxp%E8%84%9A%E6%9C%AC%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="rmxp" scheme="http://azkoree.github.io/tags/rmxp/"/>
    
    <category term="游戏开发" scheme="http://azkoree.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="学习" scheme="http://azkoree.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
